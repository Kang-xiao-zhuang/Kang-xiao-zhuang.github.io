<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4.05</title>
    <url>/2021/04/05/4-05/</url>
    <content><![CDATA[<h2 id="今天天气真好"><a href="#今天天气真好" class="headerlink" title="今天天气真好"></a>今天天气真好</h2><h2 id="适合出去嗨！"><a href="#适合出去嗨！" class="headerlink" title="适合出去嗨！"></a>适合出去嗨！</h2><hr>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/05/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2021/04/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h2><ul>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含<br>运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</li>
</ul>
<h3 id="1-Docker镜像加载原理"><a href="#1-Docker镜像加载原理" class="headerlink" title="1.Docker镜像加载原理"></a>1.Docker镜像加载原理</h3><ul>
<li>UnionFS（联合文件系统）</li>
</ul>
<blockquote>
<p>UnionFS（联合文件系统）：<strong>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统</strong>，<br>它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系<br>统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基<br>础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>特性：<strong>一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件</strong><br><strong>系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</strong></p>
</blockquote>
<ul>
<li>Docker镜像加载原理</li>
</ul>
<blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启<br>动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是<br>一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已<br>由bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标<br>准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
</blockquote>
<ul>
<li>分层镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis  #拉取redis</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306152500153.png" alt="image-20210306152500153"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image inspect redis:latest # 查看镜像分层的方式</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306152556075.png" alt="image-20210306152556075"></p>
<ul>
<li>为什么Docker镜像采用分层的结构</li>
</ul>
<blockquote>
<p>资源共享  比如有多个镜像都从相同的Base镜像构建而来，那么宿主机<br>只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服<br>务了，而且镜像的每一层都可以被共享。</p>
</blockquote>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之<br>上，创建新的镜像层。<br>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果<br>在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就<br>会创建第三个镜像层。<br>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306152903863.png" alt="image-20210306152903863"></p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了<br>一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306152919748.png" alt="image-20210306152919748"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。<br>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件<br>7 是文件 5 的一个更新版本。</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306152937874.png" alt="image-20210306152937874"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新<br>镜像层添加到镜像当中。<br>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统<br>一的文件系统。<br>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储<br>引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。<br>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分<br>层和 CoW[1]。<br>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306153005448.png" alt="image-20210306153005448"></p>
<ul>
<li>特点</li>
</ul>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！<br>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h3 id="2-镜像Commit"><a href="#2-镜像Commit" class="headerlink" title="2.镜像Commit"></a>2.镜像Commit</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit # 从容器创建一个新的镜像</span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、从Docker Hub 下载tomcat镜像到本地并运行 -it 交互终端 -p 端口映射</span></span><br><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：坑爹：docker启动官方tomcat镜像的容器，发现404是因为使用了加速器，而加速器里的tomcat的webapps下没有root等文件！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载tomcat官方镜像，就是这个镜像（阿里云里的tomcat的webapps下没有任何文件）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入tomcat查看<span class="built_in">cd</span>到webapps下发现全部空的，反而有个webapps.dist里有对应文件，cp -r到webapps下！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.进入到tomcat目录中</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line">/usr/local/tomcat # ce webapps/</span><br><span class="line">/usr/local/tomcat/webapps # ls -l # 查看是否存在 docs文件夹</span><br><span class="line">/usr/local/tomcat/webapps # curl localhost:8080/docs/  # 可以看到 docs 返回的</span><br><span class="line">内容</span><br><span class="line">/usr/local/tomcat/webapps # rm -rf docs # 删除它</span><br><span class="line">/usr/local/tomcat/webapps # curl localhost:8080/docs/  # 再次访问返回404</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、当前运行的tomcat实例就是一个没有docs的容器，我们使用它为模板commit一个没有docs的</span></span><br><span class="line">tomcat新镜像， tomcat02</span><br><span class="line"></span><br><span class="line">docker ps -l  # 查看容器的id</span><br><span class="line"></span><br><span class="line">[root@bogon ~]# docker ps -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">46e66e5d6c69        docker.io/tomcat    &quot;catalina.sh run&quot;   10 minutes ago      Up 10 minutes       8080/tcp            focused_khorana</span><br><span class="line">[root@bogon ~]# docker commit -a=&quot;zhuangkang&quot; -m=&quot;no tomcat docs&quot; 46e66e5d6c69 tomcat02:1.1</span><br><span class="line">sha256:a054127ff9bcfbbfad569cfc1cf52a20987774320ba060e4989f412cb7650f60</span><br><span class="line">[root@bogon ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">tomcat02            1.1                 a054127ff9bc        About a minute ago   672 MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、这个时候，我们的镜像都是可以使用的，大家可以启动原来的tomcat，和我们新的tomcat02来</span></span><br><span class="line">测试看看！</span><br><span class="line">[root@kuangshen ~]# docker run -it -p 8080:8080 tomcat02:1.1</span><br><span class="line"></span><br><span class="line">测试 LinuxIP:8080 访问成功！</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306154214974.png" alt="image-20210306154214974"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306155234112.png" alt="image-20210306155234112"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306155710543.png" alt="image-20210306155710543"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306160248850.png" alt="image-20210306160248850"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306160727354.png" alt="image-20210306160727354"></p>
<h2 id="2-容器数据卷"><a href="#2-容器数据卷" class="headerlink" title="2.容器数据卷"></a>2.容器数据卷</h2><h3 id="2-1docker理念回顾"><a href="#2-1docker理念回顾" class="headerlink" title="2.1docker理念回顾"></a>2.1docker理念回顾</h3><p>将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够<br>持久化的！<br>就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！<br>所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过docker commit 生成<br>新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行<br>不通的！<br>为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除<br>而丢失了！</p>
<h3 id="2-2作用"><a href="#2-2作用" class="headerlink" title="2.2作用"></a>2.2作用</h3><p>作用：<br>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此<br>能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性：<br>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂<br>载的数据卷。</p>
<h3 id="2-3特点"><a href="#2-3特点" class="headerlink" title="2.3特点"></a>2.3特点</h3><p>1、数据卷可在容器之间共享或重用数据<br>2、卷中的更改可以直接生效<br>3、数据卷中的更改不会包含在镜像的更新中<br>4、数据卷的生命周期一直持续到没有容器使用它为止<br><strong>所以：总结一句话： 就是容器的持久化，以及容器间的继承和数据共享！</strong></p>
<h2 id="3-使用数据卷"><a href="#3-使用数据卷" class="headerlink" title="3.使用数据卷"></a>3.使用数据卷</h2><ul>
<li>方式一：容器中 直接用命令来添加</li>
</ul>
<p>挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</span><br><span class="line"># 测试</span><br><span class="line">[root@root~]# docker run -it -v &#x2F;home&#x2F;ceshi:&#x2F;home centos &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>查看数据卷是否挂载成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<p>测试容器和宿主机之间数据是否共享！</p>
<p>测试容器停止退出后，主机修改数据是否会同步！</p>
<ol>
<li>停止容器</li>
<li>在宿主机上修改文件，增加些内容</li>
<li>启动刚才停止的容器</li>
<li>然后查看对应的文件，发现数据依旧同步！ok</li>
</ol>
<h2 id="4-使用docker安装mysql"><a href="#4-使用docker安装mysql" class="headerlink" title="4.使用docker安装mysql"></a>4.使用docker安装mysql</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.搜索镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.拉取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3启动容器 -e 环境变量！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意： mysql的数据应该不丢失！先体验下 -v 挂载卷！</span></span><br><span class="line">docker run -d -p 3310:3306 -v</span><br><span class="line">/home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e</span><br><span class="line">MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、使用本地的sqlyog连接测试一下 3310</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、查看本地的 /home/mysql 目录 <span class="built_in">pwd</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、删除mysql容器</span></span><br><span class="line">docker rm -f mysql01</span><br></pre></td></tr></table></figure>

<h2 id="5-匿名和具名挂载"><a href="#5-匿名和具名挂载" class="headerlink" title="5.匿名和具名挂载"></a>5.匿名和具名挂载</h2><p>以nginx为例！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载的缺点，就是不好维护，通常使用命令 docker volume维护</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">-v 卷名:/容器内路径</span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看挂载的路径</span></span><br><span class="line">docker volume inspect nginxconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 怎么判断挂载的是卷名而不是本机目录名？</span></span><br><span class="line">不是/开始就是卷名，是/开始就是目录名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变文件的读写权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro: <span class="built_in">readonly</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rw: readwrite</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定容器对我们挂载出来的内容的读写权限</span></span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<h2 id="6-DockerFile"><a href="#6-DockerFile" class="headerlink" title="6.DockerFile"></a>6.DockerFile</h2><p>微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。<br>流程：开发应用=&gt;DockerFile=&gt;打包为镜像=&gt;上传到仓库（私有仓库，公有仓库）=&gt; 下载镜像 =&gt; 启动<br>运行。</p>
<h3 id="6-1概念"><a href="#6-1概念" class="headerlink" title="6.1概念"></a>6.1概念</h3><p>dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。<br>构建步骤：<br>1、编写DockerFile文件<br>2、docker build 构建镜像<br>3、docker run</p>
<h3 id="6-2DockerFile构建过程"><a href="#6-2DockerFile构建过程" class="headerlink" title="6.2DockerFile构建过程"></a>6.2DockerFile构建过程</h3><h4 id="6-2-1基础知识"><a href="#6-2-1基础知识" class="headerlink" title="6.2.1基础知识"></a>6.2.1基础知识</h4><p>1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br>2、指令按照从上到下，顺序执行<br>3、# 表示注释<br>4、每条指令都会创建一个新的镜像层，并对镜像进行提交</p>
<h4 id="6-2-2流程"><a href="#6-2-2流程" class="headerlink" title="6.2.2流程"></a>6.2.2流程</h4><p>1、docker从基础镜像运行一个容器<br>2、执行一条指令并对容器做出修改<br>3、执行类似 docker commit 的操作提交一个新的镜像层<br>4、Docker再基于刚提交的镜像运行一个新容器<br>5、执行dockerfile中的下一条指令直到所有指令都执行完成！</p>
<h4 id="6-2-3说明"><a href="#6-2-3说明" class="headerlink" title="6.2.3说明"></a>6.2.3说明</h4><p>从应用软件的角度来看，DockerFile，docker镜像与docker容器分别代表软件的三个不同阶段。<br>DockerFile 是软件的原材料 （代码）<br>Docker 镜像则是软件的交付品 （.apk）<br>Docker 容器则是软件的运行状态 （客户下载安装执行）<br>DockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！</p>
<p>DockerFile：需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容<br>包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进<br>程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权<br>限控制）等等。<br>Docker镜像：在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行<br>Docker 镜像时，会真正开始提供服务；<br>Docker容器：容器是直接提供服务的。</p>
<h2 id="7-DockerFile指令"><a href="#7-DockerFile指令" class="headerlink" title="7.DockerFile指令"></a>7.DockerFile指令</h2><h4 id="7-1关键字"><a href="#7-1关键字" class="headerlink" title="7.1关键字"></a>7.1关键字</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM     # 基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line">MAINTAINER  # 镜像维护者的姓名混合邮箱地址</span><br><span class="line">RUN      # 容器构建时需要运行的命令</span><br><span class="line">EXPOSE    # 当前容器对外保留出的端口</span><br><span class="line">WORKDIR    # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点</span><br><span class="line">ENV      # 用来在构建镜像过程中设置环境变量</span><br><span class="line">ADD      # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span><br><span class="line">COPY     # 类似ADD，拷贝文件和目录到镜像中！</span><br><span class="line">VOLUME    # 容器数据卷，用于数据保存和持久化工作</span><br><span class="line">CMD      # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最</span><br><span class="line">后一个生效！</span><br><span class="line">ENTRYPOINT  # 指定一个容器启动时要运行的命令！和CMD一样</span><br><span class="line">ONBUILD    # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的</span><br><span class="line">ONBUILD被触发</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306162408373.png" alt="image-20210306162408373"></p>
<h3 id="7-2自定义一个centos"><a href="#7-2自定义一个centos" class="headerlink" title="7.2自定义一个centos"></a>7.2自定义一个centos</h3><h4 id="7-2-1-编写DockerFile"><a href="#7-2-1-编写DockerFile" class="headerlink" title="7.2.1.编写DockerFile"></a>7.2.1.编写DockerFile</h4><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306162536380.png" alt="image-20210306162536380"></p>
<p>目的：使我们自己的镜像具备如下：登陆后的默认路径、vim编辑器、查看网络配置ifconfig支持<br>准备编写DockerFlie文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.创建一个目录</span></span><br><span class="line">mkdir dockerfile-test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.编写文件</span></span><br><span class="line">vim mydockerfile-test</span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER zhuangkang&lt;2247830091@qq.com&gt;</span><br><span class="line">ENV MYPATH /usr/local # 默认路径</span><br><span class="line">WORKDIR $MYPATH  # 工作路径</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;----------end--------&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过cat命令查看</span></span><br><span class="line">cat mydockerfile-test</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-构建"><a href="#7-2-2-构建" class="headerlink" title="7.2.2.构建"></a>7.2.2.构建</h4><p>docker build -f dockerfile地址 -t 新镜像名字:TAG .</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f mydockerfile-centos -t mycentos:0.1</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看到下面就是成功！</span></span><br><span class="line">Successfully built 18888023317c</span><br><span class="line">Successfully tagged mycentos:0.1</span><br></pre></td></tr></table></figure>

<h4 id="7-2-3-运行"><a href="#7-2-3-运行" class="headerlink" title="7.2.3. 运行"></a>7.2.3. 运行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG</span><br></pre></td></tr></table></figure>

<h4 id="7-2-4-列出镜像地的变更历史"><a href="#7-2-4-列出镜像地的变更历史" class="headerlink" title="7.2.4.列出镜像地的变更历史"></a>7.2.4.列出镜像地的变更历史</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure>

<h2 id="8-Docker网络"><a href="#8-Docker网络" class="headerlink" title="8.Docker网络"></a>8.Docker网络</h2><p>首先清空所有容器和镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f $(docker ps -a -q)       # 删除所有容器</span><br><span class="line">docker rmi -f $(docker images -qa)      # 删除全部镜像</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306163506426.png" alt="image-20210306163506426"></p>
<p>实际场景中，我们开发了很多微服务项目，那些微服务项目都要连接数据库，需要指定数据库的url地<br>址，通过ip。但是我们用Docker管理的话，假设数据库出问题了，我们重新启动运行一个，这个时候数<br>据库的地址就会发生变化，docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的。<br>我们可以测试下容器之间能不能ping通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bogon ~]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">12: eth0@if13: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe11:2/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@bogon ~]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.089 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.048 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.060 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.047 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.045 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-1原理"><a href="#8-1原理" class="headerlink" title="8.1原理"></a>8.1原理</h4><ul>
<li><p>1、每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。这是个桥接网卡，使用了veth-pair<br>技术！</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306164255054.png" alt="image-20210306164405468"></p>
</li>
</ul>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306163525959.png" alt="image-20210306163525959"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306163607386.png" alt="image-20210306163607386"></p>
<ul>
<li>2.每启动一个容器，linux主机就会多了一个虚拟网卡。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name tomcat02 tomcat	# 再启动一个tomcat2</span><br><span class="line"></span><br><span class="line">docker exec -it tomcat02 ip addr # 查看ip</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察现象：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat --- linux主机 vethc8584ea@if122 ---- 容器内 eth0@if123</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tomcat --- linux主机 veth021eeea@if124 ---- 容器内 eth0@if125</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3.网络模型图</li>
</ul>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306164643127.png" alt="image-20210306164643127"></p>
<ul>
<li><p>4.结论</p>
</li>
<li><p>tomcat1和tomcat2共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动<br>默认都是docker0网络。<br>docker默认会给容器分配一个可用ip。</p>
</li>
<li><p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据<br>Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网<br>关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接<br>通信。</p>
</li>
</ul>
<h3 id="8-2所有网络模式"><a href="#8-2所有网络模式" class="headerlink" title="8.2所有网络模式"></a>8.2所有网络模式</h3><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210306164928025.png" alt="image-20210306164928025"></p>
<h2 id="9-部署Redis集群"><a href="#9-部署Redis集群" class="headerlink" title="9.部署Redis集群"></a>9.部署Redis集群</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建网卡</span></span><br><span class="line">docker network create redis --subnet 172.38.0.0/16</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过脚本创建六个redis配置</span></span><br><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line">docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/data:/data \</span><br><span class="line">-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server</span><br><span class="line">/etc/redis/redis.conf; \</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动6个容器</span></span><br><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">-v /mydata/redis/node-1/data:/data \</span><br><span class="line">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">docker run -p 6376:6379 -p 16376:16379 --name redis-6 \</span><br><span class="line">-v /mydata/redis/node-6/data:/data \</span><br><span class="line">-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入一个redis，注意这里是 sh命令</span></span><br><span class="line">docker exec -it redis-1 /bin/sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建集群</span></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379</span><br><span class="line">172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --</span><br><span class="line">cluster-replicas 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接集群</span></span><br><span class="line">redis-cli -c</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息</span></span><br><span class="line">cluster info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点</span></span><br><span class="line">cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> a b</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止到存值的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后再次get a，发现依旧可以获取值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看节点，发现高可用完全没问题</span></span><br></pre></td></tr></table></figure>

<h2 id="10-IDEA整合Redis"><a href="#10-IDEA整合Redis" class="headerlink" title="10.IDEA整合Redis"></a>10.IDEA整合Redis</h2><ul>
<li>1.创建一个SpringBoot项目</li>
<li>2.创建一个HelloController</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.启动测试，确认端口没有冲突</li>
<li>4.用Maven打成jar包</li>
<li>打包镜像</li>
<li>1.在项目下编写 Dockerfile 文件，将打包好的jar包拷贝到Dockerfile同级目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务器只有dockerfile和jar在同级目录</span></span><br><span class="line">COPY *.jar /app.jar</span><br><span class="line">CMD [&quot;--server.port=8080&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定容器内要暴露的端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>2.将Dockerfile 和 项目的 jar 包上传到linux服务器上，构建运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">docker build -t idea-ks .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">docker run -d -P --name idea-ks idea-ks</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line">curl localhost:32779</span><br><span class="line">curl localhost:32779/hello</span><br></pre></td></tr></table></figure>

<h2 id="11-常用命令总结"><a href="#11-常用命令总结" class="headerlink" title="11.常用命令总结"></a>11.常用命令总结</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/20200526095411.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> attach    Attach to a running container                 <span class="comment"># 当前 shell 下 attach 连接指定运行镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> build     Build an image from a Dockerfile              <span class="comment"># 通过 Dockerfile 定制镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> commit    Create a new image from a container changes   <span class="comment"># 提交当前容器为新的镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp        Copy files/folders from the containers filesystem to the host path   <span class="comment">#从容器中拷贝指定文件或者目录到宿主机中</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> create    Create a new container                        <span class="comment"># 创建一个新的容器，同 run，但不启动容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> diff      Inspect changes on a container<span class="string">&#x27;s filesystem   # 查看 docker 容器变化</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> events    Get real time events from the server          <span class="comment"># 从 docker 服务获取容器实时事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span>      Run a <span class="built_in">command</span> <span class="keyword">in</span> an existing container        <span class="comment"># 在已存在的容器上运行命令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span>    Stream the contents of a container as a tar archive   <span class="comment"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">history</span>   Show the <span class="built_in">history</span> of an image                  <span class="comment"># 展示一个镜像形成历史</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> images    List images                                   <span class="comment"># 列出系统当前镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> import    Create a new filesystem image from the contents of a tarball <span class="comment"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> info      Display system-wide information               <span class="comment"># 显示系统相关信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> inspect   Return low-level information on a container   <span class="comment"># 查看容器详细信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span>      Kill a running container                      <span class="comment"># kill 指定 docker 容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> load      Load an image from a tar archive              <span class="comment"># 从一个 tar 包中加载一个镜像[对应 save]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> login     Register or Login to the docker registry server    <span class="comment"># 注册或者登陆一个 docker 源服务器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">logout</span>    Log out from a Docker registry server          <span class="comment"># 从当前 Docker registry 退出</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> logs      Fetch the logs of a container                 <span class="comment"># 输出当前容器日志信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> port      Lookup the public-facing port <span class="built_in">which</span> is NAT-ed to PRIVATE_PORT    <span class="comment"># 查看映射端口对应的容器内部源端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pause     Pause all processes within a container        <span class="comment"># 暂停容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps        List containers                               <span class="comment"># 列出容器列表</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> pull      Pull an image or a repository from the docker registry server   <span class="comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> push      Push an image or a repository to the docker registry server   <span class="comment"># 推送指定镜像或者库镜像至docker源服务器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> restart   Restart a running container                   <span class="comment"># 重启运行的容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm        Remove one or more containers                 <span class="comment"># 移除一个或者多个容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> rmi       Remove one or more images             <span class="comment"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> run       Run a <span class="built_in">command</span> <span class="keyword">in</span> a new container              <span class="comment"># 创建一个新的容器并运行一个命令</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> save      Save an image to a tar archive                <span class="comment"># 保存一个镜像为一个 tar 包[对应 load]</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> search    Search <span class="keyword">for</span> an image on the Docker Hub         <span class="comment"># 在 docker hub 中搜索镜像</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> start     Start a stopped containers                    <span class="comment"># 启动容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> stop      Stop a running containers                     <span class="comment"># 停止容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> tag       Tag an image into a repository                <span class="comment"># 给源中镜像打标签</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> top       Lookup the running processes of a container   <span class="comment"># 查看容器中运行的进程信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> unpause   Unpause a paused container                    <span class="comment"># 取消暂停容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> version   Show the docker version information           <span class="comment"># 查看 docker 版本号</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">wait</span>      Block until a container stops, <span class="keyword">then</span> <span class="built_in">print</span> its <span class="built_in">exit</span> code   <span class="comment"># 截取容器停止时的退出状态值</span></span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
  </entry>
  <entry>
    <title>RabbitMQ学习笔记</title>
    <url>/2021/04/18/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<h1 id="RabbitMQ学习笔记"><a href="#RabbitMQ学习笔记" class="headerlink" title="RabbitMQ学习笔记"></a>RabbitMQ学习笔记</h1><p><strong>学习地址:<a href="https://www.bilibili.com/video/BV1dX4y1V73G">https://www.bilibili.com/video/BV1dX4y1V73G</a></strong></p>
<p><strong>仓库地址:<a href="https://gitee.com/zhuang-kang/rabbit-mq">https://gitee.com/zhuang-kang/rabbit-mq</a></strong></p>
<h1 id="1，什么是中间件"><a href="#1，什么是中间件" class="headerlink" title="1，什么是中间件"></a>1，什么是中间件</h1><p>一个企业可能运行多个不同业务系统，可能基于不同的操作系统，不同数据库，异构的网络环境，问题是，如何把这些信息系统结合结合成一个有机地协同工作的整体，真正实现跨平台，分布式应用，中间件便是解决之道</p>
<ul>
<li><strong>中间件：</strong>处于操作系统和应用程序之间的软件，在中间件中必须要有一个通信中间件，即 中间件=平台＋通信，这个定义也限定只有用于分布式，同时还可以把它与支撑软件和试用软件分开来</li>
</ul>
<blockquote>
<p>1,RMI 远程调用</p>
<p>2，Load Balancing 负载均衡 将访问负荷分散到各个服务器中</p>
<p>3，Clustering 集群 用多个小服务器代替大型机</p>
<p>4，Threading 多线程处理</p>
<p>5，Transaction 事务</p>
<p>6，Component Life Cycle 组件的生命周期管理</p>
<p>……</p>
</blockquote>
<h2 id="1-2-为什么需要使用中间件"><a href="#1-2-为什么需要使用中间件" class="headerlink" title="1.2 为什么需要使用中间件"></a>1.2 为什么需要使用中间件</h2><p>具体说，中间件屏蔽底层操作系统的复杂性，使程序员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必为程序在不同软件上的移植而重复工作，减少技术负担，开发的简便，开发周期短，减少系统维护，减少费用投入</p>
<h2 id="1-3-中间件的特点"><a href="#1-3-中间件的特点" class="headerlink" title="1.3 中间件的特点"></a>1.3 中间件的特点</h2><p>中间件是位于平台（硬件和操作系统）和应用之间的通用服务，针对不同操作系统和硬件平台，可以有符合接口和协议的多种实现</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_14-43-35.png"></p>
<p><strong>特点如下：</strong></p>
<ul>
<li>满足大量应用的需求</li>
<li>运行于多种硬件和OS平台</li>
<li>支持分布计算，提供网络，硬件和OS平台的透明性的应用或服务的交互</li>
<li>支持标准的协议</li>
<li>支持标准的接口</li>
</ul>
<blockquote>
<p>简单说，中间件有个很大的特点，脱离于具体设计目标，而具备提供普遍独立功能需求的模块。使得中间件是可替换的，如果一个系统设计中，中间件是不可替换的，不是架构，框架设计有问题，就是中间件出现问题</p>
</blockquote>
<h2 id="1-4-什么时候使用中间件技术"><a href="#1-4-什么时候使用中间件技术" class="headerlink" title="1.4 什么时候使用中间件技术"></a>1.4 什么时候使用中间件技术</h2><p>在项目的架构和重构中，使用任何技术和架构的改变我们都需要谨慎斟酌和思考，因为任何技术的融入和变化都可能人员，技术，和威本的增加，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果你仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而追求的背后一定是业务的驱动和项目的驱动，因为一旦追求就意味着你的学习成本，公司的人员结构以及服务器成本，维护和运维的成本都会增加，所以需要谨慎选择和考虑。</p>
<p>但是作为一个开放人员，一定要有学习中间件技术的能力和思维，否则很容易当项目发展到一个阶段在去掌握估计或者在面试中提及，就会给自己带来不小的困扰，在当今这个时代这些技术也并不是什么新鲜的东西，如果去掌握和挖掘最关键的还是自己花时间和花精力去探讨和研究</p>
<h1 id="2，中间件技术及架构的概述"><a href="#2，中间件技术及架构的概述" class="headerlink" title="2，中间件技术及架构的概述"></a>2，中间件技术及架构的概述</h1><h2 id="2-1-什么是中间件"><a href="#2-1-什么是中间件" class="headerlink" title="2.1 什么是中间件"></a>2.1 什么是中间件</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_14-54-46.png"></p>
<h2 id="2-2-单体架构"><a href="#2-2-单体架构" class="headerlink" title="2.2 单体架构"></a>2.2 单体架构</h2><p>在企业开发的中，大部分的初期架构都采用的是单体架构的模式进行架构，而这种架构的典型的特点:就是把所有的业务和模块，源代码，静态资源文件等都放在一个一工程中，如果其中的一个模块升级或者迭代发生一个很小变动都会重新编译和重新部看项目。这种的架构存在的问题就是:</p>
<ul>
<li>耦合度太高</li>
<li>运维成本过高</li>
<li>不易维护</li>
<li>服务器成本高</li>
<li>后续复杂度增加</li>
</ul>
<h2 id="2-3-分布式架构"><a href="#2-3-分布式架构" class="headerlink" title="2.3 分布式架构"></a>2.3 分布式架构</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_14-58-39.png"></p>
<p>何谓分布式系统呢:</p>
<blockquote>
<p>通俗一点:就是一个请求由服务器端的多个服务(服务或者系统)协同处理完成</p>
</blockquote>
<p>和单体架构不同的是，单体架构是一个请求发起ivm调度线程（确切的是tomcat线程池）分配线程Thread来处理请求直到释放，而分布式是系统是:一个请求是由多个系统共同来协同完成，jvm和环境都可能是独立。如果生活中的比喻的话，单体架构就想建设一个小房子很快就能够搞定，如果你要建设一个鸟巢者大型的建筑，你就必须是各个环节的协同和分布，这样目的也是项目发展都后期的时候要去部署和思考的问题。我们也不能看出来:分布式架构系统存在的特点和问题如下:</p>
<p><strong>存在问题</strong></p>
<ul>
<li>学习成本高，技术栈过多</li>
<li>运维成本和服务器成本增加</li>
<li>人员成本增高</li>
<li>项目负载度上升</li>
<li>面临错误和容错性增加</li>
<li>占用服务器端口和通讯选择成本高</li>
<li>安全性的考虑和因素逼迫选择RMI/MQ相关服务器通讯</li>
</ul>
<p><strong>好处</strong></p>
<ul>
<li>服务系统的独立，占用的服务器资源减少和占用的硬件成本减少，确切的说是:可以合理的分配服务资源，不造成服务器资源的浪费</li>
<li>系统的独立维护和部署，耦合度降低，可插拔性。</li>
<li>系统的架构和技术栈的选择可以变的灵活(而不是单纯的选择java)</li>
</ul>
<h1 id="3，基于中间件技术的架构"><a href="#3，基于中间件技术的架构" class="headerlink" title="3，基于中间件技术的架构"></a>3，基于中间件技术的架构</h1><h2 id="3-1-消息中间价的架构"><a href="#3-1-消息中间价的架构" class="headerlink" title="3.1 消息中间价的架构"></a>3.1 消息中间价的架构</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_15-04-20.png"></p>
<blockquote>
<p>从上图看出 消息中间件是</p>
<p>1，利用可靠的消息传递机制进行系统直接通讯</p>
<p>2，通过提供可靠消息和消息的排队机制，可以在分布式系统下扩展进程间的通讯</p>
</blockquote>
<h2 id="3-2-消息中间件的应用场景"><a href="#3-2-消息中间件的应用场景" class="headerlink" title="3.2 消息中间件的应用场景"></a>3.2 消息中间件的应用场景</h2><ul>
<li>跨系统数据传递</li>
<li>高并发的流量削峰</li>
<li>数据的分发和异步处理</li>
<li>大数据分析与传递</li>
<li>分布式事务</li>
</ul>
<h2 id="3-3-常见的消息中间件"><a href="#3-3-常见的消息中间件" class="headerlink" title="3.3 常见的消息中间件"></a>3.3 常见的消息中间件</h2><p>ActiveMQ、RabbitMQ、Kafka、RocketMQ等。</p>
<h2 id="3-4-消息中间件的本质及设计"><a href="#3-4-消息中间件的本质及设计" class="headerlink" title="3.4 消息中间件的本质及设计"></a>3.4 消息中间件的本质及设计</h2><p>它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</p>
<blockquote>
<p>MQ消息队列:负责数据的传接受，存储和传递，所以性能要过于普通服务和技术。</p>
</blockquote>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_15-12-04.png"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-14_15-12-12.png" alt="Snipaste_2021-04-14_15-12-12"></p>
<h2 id="3-5-消息中间件的核心组成部分"><a href="#3-5-消息中间件的核心组成部分" class="headerlink" title="3.5 消息中间件的核心组成部分"></a>3.5 消息中间件的核心组成部分</h2><ul>
<li>消息的协议</li>
<li>消息的持久化机制</li>
<li>消息的分发策略</li>
<li>消息的高可用</li>
<li>消息的容错机制</li>
</ul>
<h2 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h2><p>其实不论选择单体架构还是分布式架构都是项目开发的一个阶段，在什么阶段选择适合的架构方式，而不能盲目追求,最后造成的后果和问题都需要自己买单。但是作为一个开发人员学习和探讨新的技术是我们每个程序开发者都应该去保持和思考的问题。当我们没办法去改变社会和世界的时候，我们为了生活和生存那就必须要迎合企业和市场的需求，发挥你的价值和所学的才能，创造价值和实现自我。</p>
<h1 id="4，消息队列协议"><a href="#4，消息队列协议" class="headerlink" title="4，消息队列协议"></a>4，消息队列协议</h1><h2 id="4-1-什么是协议"><a href="#4-1-什么是协议" class="headerlink" title="4.1 什么是协议"></a>4.1 什么是协议</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-04-58.png"></p>
<p>我们知道消息中间件负责数据的传递，存储，和分发消费三个部分，数据的存储和分发的过程中肯定要遵循某种约定成俗的规范，你是采用底层的TCP/IPJT, UDP协议还是其他的自己取构建等，而这些约定成俗的规范就称之为:协议。</p>
<blockquote>
<p>所谓协议是指:<br>1:计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。<br>2:和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</p>
<p>3:协议对数据格式和计算机之间交换数据都必须严格遵守规范。</p>
</blockquote>
<h2 id="4-2-网络协议的三要素"><a href="#4-2-网络协议的三要素" class="headerlink" title="4.2 网络协议的三要素"></a>4.2 网络协议的三要素</h2><p>1.语法。语法是用户数据与控制信息的结构与格式,以及数据出现的顺序。<br>2.语义。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息,以及完成的动作与做出什么样的响应。3.时序。时序是对事件发生顺序的详细说明。</p>
<p>比如我MQ发送一个信息，是以什么数据格式发送到队列中，然后每个部分的含义是什么，发送完毕以后的执行的动作,以及消费者消费消息的动作，消费完毕的响应结果和反馈是什么，然后按照对应的执行顺序进行处理。如果你还是不理解:大家每天都在接触的http请求协议:</p>
<p><strong>1:语法:http规定了请求报文和响应报文的格式。</strong></p>
<p><strong>2:语义:客户端主动发起请求称之为请求。(这是一种定义，同时你发起的是post/get请求)</strong></p>
<p><strong>3:时序:一个请求对应一个响应。(一定先有请求在有响应，这个是时序)</strong></p>
<p>而消息中间件采用的并不是http协议，而常见的消息中间件协议有:OpenWire、AMQP、MQTT、Kafka,OpenMessage协议。<br><strong>面试题:为什么消息中间件不直接使用http协议呢?</strong></p>
<ul>
<li>1:因为http请求报文料和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。</li>
<li>2:大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</li>
</ul>
<h2 id="4-3-AMQP协议"><a href="#4-3-AMQP协议" class="headerlink" title="4.3 AMQP协议"></a>4.3 AMQP协议</h2><p>AMQP:(全称: Advanced Message Queuing Protocol)是高级消息队列协议。由摩根大通集团联合其他公司共同设计。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等。</p>
<p>特性:<br>1:分布式事务支持。</p>
<p>2:消息的持久化支持。</p>
<p>3:高性能和高可靠的消息处理优势。</p>
<h2 id="4-4-MQTT协议"><a href="#4-4-MQTT协议" class="headerlink" title="4.4 MQTT协议"></a>4.4 MQTT协议</h2><p>MQTT协议: (Message Queueing Telemetry Transport)消息队列是IBM开放的一个即时通讯协议，物联网系统架构中的重要组成部分。</p>
<p><strong>特点:</strong></p>
<ul>
<li><p>轻量</p>
</li>
<li><p>结构简单</p>
</li>
<li><p>传输快，不支持事务</p>
</li>
<li><p>没有持久化设计</p>
</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><p>适用于计算能力有限</p>
</li>
<li><p>低带宽</p>
</li>
<li><p>网络不稳定的场景。支持者:</p>
</li>
</ul>
<h2 id="4-5-OpenMessage协议"><a href="#4-5-OpenMessage协议" class="headerlink" title="4.5 OpenMessage协议"></a>4.5 OpenMessage协议</h2><p>是近几年由阿里、雅r虎和滴滴出行、Stremalio等公司共同参与创立的分布式消息中间件、流处理等领域的应用开发标准。<br>特点:</p>
<p>1∶结构简单</p>
<p>2∶解析速度快</p>
<p>3:支持事务和持久化设计。</p>
<h2 id="4-6-Kafaka协议"><a href="#4-6-Kafaka协议" class="headerlink" title="4.6 Kafaka协议"></a>4.6 Kafaka协议</h2><p>Kafka协议是基于TCP/IP的二进制协议。消想内部是通过长度来分割，由一些基本数据类型组成特点是:<br>1:结构的单一</p>
<p>2:解析速度快</p>
<p>3:无事务支持</p>
<p>4:有持久化设计</p>
<h2 id="4-7-小结"><a href="#4-7-小结" class="headerlink" title="4.7 小结"></a>4.7 小结</h2><p>协议:是在tcp/ip协议基础之上构建的一种约定成俗的规范和机制、它的主要目的可以让客户端（应用程序java，go)进行沟通和通讯。并且这种协议下规范必须具有持久性，高可用，高可靠的性能。</p>
<h1 id="5，消息分发策略"><a href="#5，消息分发策略" class="headerlink" title="5，消息分发策略"></a>5，消息分发策略</h1><p><strong>MQ消息队列有如下几个角色</strong></p>
<p>1:生产者</p>
<p>2:存储消息</p>
<p>3∶消费者<br>那么生产者生成消息以后，MQ进行存储，消费者是如何获取消息的呢?一般获取数据的方式无外乎推(push）或者拉(pull)两种方式，典型的git就有推拉机制，我们发送的http请求就是一种典型的拉取数据库数据返回的过程。而消息队列MQ是一种推送的过程，而这些推机制会适用到很多的业务场景也有很多对应推机制策略。</p>
<h2 id="5-2-场景分析1"><a href="#5-2-场景分析1" class="headerlink" title="5.2 场景分析1"></a>5.2 场景分析1</h2><p><img src=""><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-18-03.png" alt="Snipaste_2021-04-15_21-18-03"></p>
<blockquote>
<p>比如我在APP上下了一个订单，我们的系统和服务很多，我们如何得知这个消息被那个系统或者那些服务或者系统进行消费，那这个时候就需要一个分发的策略。这就需要消费策略。或者称之为消费的方法论。</p>
</blockquote>
<h2 id="5-2-场景分析2"><a href="#5-2-场景分析2" class="headerlink" title="5.2 场景分析2"></a>5.2 场景分析2</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-20-37.png"></p>
<blockquote>
<p>在发送消息的过程中可能会出现异常，或者网络的抖动，故障等等因为造成消息的无法消费，比如用户在下订单，消费MQ接受，订单系统出现故障，导致用户支付失败，那么这个时候就需要消息中间件就必须支持消息重试机制策略。也就是支持:出现问题和故障的情况下，消息不丢失还可以进行重发。</p>
</blockquote>
<h2 id="5-3-消息分发策略的机制和对比"><a href="#5-3-消息分发策略的机制和对比" class="headerlink" title="5.3 消息分发策略的机制和对比"></a>5.3 消息分发策略的机制和对比</h2><table>
<thead>
<tr>
<th></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>Kafaka</strong></th>
<th><strong>RocketMQ</strong></th>
</tr>
</thead>
<tbody><tr>
<td>发布订阅</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>轮询发布</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>/</td>
</tr>
<tr>
<td>公平分发</td>
<td>/</td>
<td>支持</td>
<td>支持</td>
<td>/</td>
</tr>
<tr>
<td>重发</td>
<td>支持</td>
<td>支持</td>
<td>/</td>
<td>支持</td>
</tr>
<tr>
<td>消息拉取</td>
<td>/</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h1 id="6，消息队列高可靠和高可用"><a href="#6，消息队列高可靠和高可用" class="headerlink" title="6，消息队列高可靠和高可用"></a>6，消息队列高可靠和高可用</h1><p>所谓高可用：是指产品在规定的条件和规定的时刻或时间内处于可执行规定功能状态的能力，当业务量增加时，请求也过大，一台消息中间件服务器的会触及硬件 比如CPU 内存 磁盘 的极限，一台消息服务器无法满足需求，消息中间件必须支持集群部署，来达到高可用</p>
<h2 id="6-1-集群模式1-Master-slave-主从共享数据的部署方式"><a href="#6-1-集群模式1-Master-slave-主从共享数据的部署方式" class="headerlink" title="6.1 集群模式1- Master-slave 主从共享数据的部署方式"></a>6.1 集群模式1- Master-slave 主从共享数据的部署方式</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-25-24.png"></p>
<blockquote>
<p>生产者将消费发送到Master节点,所有的都连接这个消息队列共享这块数据区域，Master节点负责写入，一旦Master挂掉，slave节点继续服务，形成高可用</p>
</blockquote>
<h2 id="6-2-集群模式2-Master-slave主从同步部署方式"><a href="#6-2-集群模式2-Master-slave主从同步部署方式" class="headerlink" title="6.2 集群模式2 Master-slave主从同步部署方式"></a>6.2 集群模式2 Master-slave主从同步部署方式</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-25-57.png"></p>
<blockquote>
<p>这种模式写入消息同样在Master主节点上，但是主节点会同步数据到slave节点形成副本，和zookeeper或者redis主从机制很类同，可以达到负载均衡的效果，如果消费者有多个这样可以去不同的节点进行消费，因为消费的拷贝和同步会回占用很大的带宽和网络资源，rabbitmq中有使用</p>
</blockquote>
<h2 id="6-3-集群模式3-多主集同步部署模式"><a href="#6-3-集群模式3-多主集同步部署模式" class="headerlink" title="6.3 集群模式3 多主集同步部署模式"></a>6.3 集群模式3 多主集同步部署模式</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-34-05.png"></p>
<blockquote>
<p>和上面差不多的模式</p>
</blockquote>
<h2 id="6-4-集群模式4-多主集群转发部署模式"><a href="#6-4-集群模式4-多主集群转发部署模式" class="headerlink" title="6.4 集群模式4 多主集群转发部署模式"></a>6.4 集群模式4 多主集群转发部署模式</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-35-51.png"></p>
<blockquote>
<p>解释:如果你插入的数据是broker-1中，元数据信息会存储数据的相关描述和记录存放的位置(队列)。<br>它会对描述信息也就是元数据信息就行同步，如果消费者在broker-2中进行消费，发现自己几点没有对应的消息，可以从对应的元数据信息中去查询，然后返回对应的消息信息，场景:比如买火车票或者黄牛买演唱会门票，比如第一个黄牛有顾客说要买的演唱会门票，但是没有但是他会去联系其他的黄牛询问，如果有就返回。</p>
</blockquote>
<h2 id="6-5-集群模式5-Mater-slave-与Broker-cluster组合的方案"><a href="#6-5-集群模式5-Mater-slave-与Broker-cluster组合的方案" class="headerlink" title="6.5 集群模式5 Mater-slave 与Broker-cluster组合的方案"></a>6.5 集群模式5 Mater-slave 与Broker-cluster组合的方案</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-37-31.png"></p>
<blockquote>
<p>解释:实现多主多从的热备机制来完成消息的高可用以及数据的热备机制，在生产规模达到一定的阶段的时候，这种使用的频率比较高。<br>这么集群模式，具体在后续的课程中会进行一个分析和讲解。他们的最终目的都是为保证︰消息服务器不会挂掉，出现了故障依然可以抱着消息服务继续使用。</p>
</blockquote>
<p><strong>三句话:</strong><br>1:要么消息共享</p>
<p>2:要么消息同步</p>
<p>3:要么元数据共享</p>
<h2 id="6-6-什么是高可靠机制"><a href="#6-6-什么是高可靠机制" class="headerlink" title="6.6 什么是高可靠机制"></a>6.6 什么是高可靠机制</h2><p>所谓高可用是指:是指系统可以无故障低持续运行，比如一个系统突然崩溃，报错，异常等等并不影响线上业务的正常运行，出错的几率极低，就称之为:高可靠。</p>
<p>在高并发的业务场景中，如果不能保证系统的高可靠，那造成的隐患和损失是非常严重的。</p>
<p>如何保证中间件消息的可靠性呢?可以从两个方面考虑:<br>1:消息的传输:通过协议来保证系统间数据解析的正确性。</p>
<p>2:消息的存储可靠:通过持久化来保证消息的可靠性。</p>
<h2 id="7，RabbitMQ安装"><a href="#7，RabbitMQ安装" class="headerlink" title="7，RabbitMQ安装"></a>7，RabbitMQ安装</h2><p><strong>参考官网：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></strong></p>
<h2 id="7-1-Docker安装"><a href="#7-1-Docker安装" class="headerlink" title="7.1 Docker安装"></a>7.1 Docker安装</h2><p>一个命令搞定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>然后通过IP地址+15672端口访问即可</p>
<p>用户名和密码都是guest</p>
<h1 id="8，RabbitMQ角色分类"><a href="#8，RabbitMQ角色分类" class="headerlink" title="8，RabbitMQ角色分类"></a>8，RabbitMQ角色分类</h1><h2 id="8-1-none"><a href="#8-1-none" class="headerlink" title="8.1 none"></a>8.1 none</h2><ul>
<li>不能访问management plugin</li>
</ul>
<h2 id="8-2-management-查看自己相关节点信息"><a href="#8-2-management-查看自己相关节点信息" class="headerlink" title="8.2 management:查看自己相关节点信息"></a>8.2 management:查看自己相关节点信息</h2><ul>
<li><p>列出自己可以通过AMQP登入的虚拟机</p>
</li>
<li><p>查看自己的虚拟机节点 virtual hosts的queues,exchanges和bindings信息</p>
</li>
<li><p>查看和关闭自己的channels和connections</p>
</li>
</ul>
<h2 id="8-3-Policymaker"><a href="#8-3-Policymaker" class="headerlink" title="8.3 Policymaker"></a>8.3 Policymaker</h2><ul>
<li><p>包含management所有权限</p>
</li>
<li><p>查看和创建和删除自己的virtual hosts所属的policies和parameters信息</p>
</li>
</ul>
<h2 id="8-4-Monitoring"><a href="#8-4-Monitoring" class="headerlink" title="8.4 Monitoring"></a>8.4 Monitoring</h2><ul>
<li>包含management所有权限</li>
<li>罗列出所有virtual hosts，包括不能登录的virtual hosts</li>
<li>查看其他用户的connections和channels信息</li>
<li>查看节点级别的数据如clustering和memory使用情况</li>
<li>查看所有的virtual hosts的全局统计信息</li>
</ul>
<h2 id="8-5-Administrator"><a href="#8-5-Administrator" class="headerlink" title="8.5  Administrator"></a>8.5  Administrator</h2><ul>
<li>最高权限</li>
<li>可以创建和删除virtual hosts·可以查看，创建和删除users</li>
<li>查看创建permisssions</li>
</ul>
<h1 id="9，入门案例-简单模式"><a href="#9，入门案例-简单模式" class="headerlink" title="9，入门案例 简单模式"></a>9，入门案例 简单模式</h1><p><strong>具体流程</strong></p>
<ul>
<li>生产者发送消息<ol>
<li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li>
<li>声明队列并设置属性；如是否排它，是否持久化，是否自动删除；</li>
<li>将路由键（空字符串）与队列绑定起来；</li>
<li>发送消息至RabbitMQ Broker；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
<li>消费者接收消息<ol>
<li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li>
<li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li>
<li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li>
<li>确认（ack，自动确认）接收到的消息；</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_15-31-15.png"></p>
<p>先导入依赖 创建Maven工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写Producer类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            String queueName = <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            String message = <span class="string">&quot;hello kang xiao zhuang&quot;</span>;</span><br><span class="line">            <span class="comment">//发送消息给队列</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写Consumer类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用一句话描述类的作用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到的消息是&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行即可！</p>
<p>查看Web端控制器</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_16-45-31.png"></p>
<p><strong>先启动生产者会发现消息，再启动消费者 控制台打印出消费的消息</strong></p>
<h1 id="10，AMQP协议"><a href="#10，AMQP协议" class="headerlink" title="10，AMQP协议"></a>10，AMQP协议</h1><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有RabbitMQ等</p>
<h2 id="10-1-AMQP生产者流转过程"><a href="#10-1-AMQP生产者流转过程" class="headerlink" title="10.1 AMQP生产者流转过程"></a>10.1 AMQP生产者流转过程</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-58-26.png"></p>
<h2 id="10-2-AMQP消费者流转过程"><a href="#10-2-AMQP消费者流转过程" class="headerlink" title="10.2 AMQP消费者流转过程"></a>10.2 AMQP消费者流转过程</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_21-59-12.png"></p>
<h1 id="11，RabbitMQ核心功能部分"><a href="#11，RabbitMQ核心功能部分" class="headerlink" title="11，RabbitMQ核心功能部分"></a>11，RabbitMQ核心功能部分</h1><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_22-02-02.png"></p>
<h2 id="11-1-核心概念"><a href="#11-1-核心概念" class="headerlink" title="11.1 核心概念"></a>11.1 核心概念</h2><p>**Server:**又称Broker ,接受客户端的连接，实现AMQP实体服务。安装rabbitmq-serverConnection:连接，应用程序与Broker的网络连接TCP/IP/三次握手和四次挥手</p>
<p>**Channel :**网络信道，几乎所有的操作都在Channel中进行，Channel是进k%息读写的通道，客户端可以建立对各Channel，每个Channel代表一个会话任务。</p>
<p>**Message :**消息:服务与应用程序之间传送的数据，由Properties和body组成，Properties可是对消息进行修饰，比如消息的优先级，延迟等高级特性，Body则就是消息体的内容。</p>
<p><strong>Virtual Host：</strong>虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个虚拟主机理由可以有若千个Exhange和Queueu，同一个虚拟主机里面不能有相同名字的Exchange</p>
<p>**Exchange:**交换机，接受消息，根据路由键发送消息到绑定的队列。(==不具备消息存储的能力==)Bindings : Exchange和Queue之问的虚拟连接，binding中可以保护多个routing key.</p>
<p>**Routing key :**是一个路由规则，虚拟机可以用它来确定如何路由一个特定消息。</p>
<p>**Queue :**队列:也成为Message Queue,消息队列，保存消息并将它们转发给消费者。</p>
<h2 id="11-2-核心架构"><a href="#11-2-核心架构" class="headerlink" title="11.2 核心架构"></a>11.2 核心架构</h2><p><img src=""><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_22-04-54.png" alt="Snipaste_2021-04-15_22-04-54"></p>
<h2 id="11-3-运行流程"><a href="#11-3-运行流程" class="headerlink" title="11.3 运行流程"></a>11.3 运行流程</h2><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_22-05-59.png"></p>
<h2 id="11-4-工作模式分类"><a href="#11-4-工作模式分类" class="headerlink" title="11.4 工作模式分类"></a>11.4 工作模式分类</h2><h3 id="11-4-1-简单模式-simple"><a href="#11-4-1-简单模式-simple" class="headerlink" title="11.4.1 简单模式 simple"></a>11.4.1 简单模式 simple</h3><ul>
<li>参考入门案例</li>
</ul>
<h3 id="11-4-2-工作模式-work"><a href="#11-4-2-工作模式-work" class="headerlink" title="11.4.2 工作模式 work"></a>11.4.2 工作模式 work</h3><ul>
<li>类型 ：无</li>
<li>特点：分发机制</li>
</ul>
<h3 id="11-4-3-发布订阅模式-fanout"><a href="#11-4-3-发布订阅模式-fanout" class="headerlink" title="11.4.3 发布订阅模式 fanout"></a>11.4.3 发布订阅模式 fanout</h3><ul>
<li>类型：fanout</li>
<li>特点：发布订阅模式，是一种广播机制，没有路由key</li>
</ul>
<h3 id="11-4-4-路由模式"><a href="#11-4-4-路由模式" class="headerlink" title="11.4.4 路由模式"></a>11.4.4 路由模式</h3><ul>
<li>类型 ：direct</li>
<li>特点：有routing-key 的匹配模式</li>
</ul>
<h3 id="11-4-5-主题模式"><a href="#11-4-5-主题模式" class="headerlink" title="11.4.5 主题模式"></a>11.4.5 主题模式</h3><ul>
<li>类型：topic</li>
<li>特点：模糊的routing-key的匹配模式</li>
</ul>
<h1 id="12，Fanout模式"><a href="#12，Fanout模式" class="headerlink" title="12，Fanout模式"></a>12，Fanout模式</h1><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    String queueName = &quot;queue1&quot;;</span></span><br><span class="line"></span><br><span class="line">            String message = <span class="string">&quot;hello fanout！！！&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//准备交换机</span></span><br><span class="line">            String exchangeName=<span class="string">&quot;fanout_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义路由Key</span></span><br><span class="line">            String routeKey=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//定义交换机类型</span></span><br><span class="line">            String type=<span class="string">&quot;fanout&quot;</span>;</span><br><span class="line">          <span class="comment">//  channel.queueDeclare(queueName, false, false, false, null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送消息给队列</span></span><br><span class="line">            channel.basicPublish(exchangeName, routeKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.routing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用一句话描述类的作用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue2&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到的消息是&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="13，Direct模式"><a href="#13，Direct模式" class="headerlink" title="13，Direct模式"></a>13，Direct模式</h1><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.direct;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消费者direct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    String queueName = &quot;queue1&quot;;</span></span><br><span class="line"></span><br><span class="line">            String message = <span class="string">&quot;hello direct !!!&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//准备交换机</span></span><br><span class="line">            String exchangeName=<span class="string">&quot;direct_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义路由Key</span></span><br><span class="line">            String routeKey=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//定义交换机类型</span></span><br><span class="line">            String type=<span class="string">&quot;direct&quot;</span>;</span><br><span class="line">          <span class="comment">//  channel.queueDeclare(queueName, false, false, false, null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送消息给队列</span></span><br><span class="line">            channel.basicPublish(exchangeName, routeKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.direct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> direct消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到的消息是&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14，Topic模式"><a href="#14，Topic模式" class="headerlink" title="14，Topic模式"></a>14，Topic模式</h1><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.topics;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 生产者主题模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    String queueName = &quot;queue1&quot;;</span></span><br><span class="line"></span><br><span class="line">            String message = <span class="string">&quot;hello topics !!!&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//准备交换机</span></span><br><span class="line">            String exchangeName=<span class="string">&quot;topic_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义路由Key</span></span><br><span class="line">            String routeKey=<span class="string">&quot;com.order.user.test.xxxx&quot;</span>;</span><br><span class="line">            <span class="comment">//定义交换机类型</span></span><br><span class="line">            String type=<span class="string">&quot;topic&quot;</span>;</span><br><span class="line">          <span class="comment">//  channel.queueDeclare(queueName, false, false, false, null);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送消息给队列</span></span><br><span class="line">            channel.basicPublish(exchangeName, routeKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.topics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 主题模式的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue3&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到的消息是&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_16-45-37.png"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_16-46-06.png" alt="Snipaste_2021-04-15_16-46-06"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_16-49-47.png" alt="Snipaste_2021-04-15_16-49-47"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-15_16-50-18.png" alt="Snipaste_2021-04-15_16-50-18"></p>
<p><strong>以上图片仅供参考，需要自己创建交换机，指定路由key</strong></p>
<h1 id="15，代码创建交换机"><a href="#15，代码创建交换机" class="headerlink" title="15，代码创建交换机"></a>15，代码创建交换机</h1><p>上面都是用web客户端创建的，现在用代码的方式创建交换机和定义队列！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.all;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明交换机名称</span></span><br><span class="line">            String exchangeName=<span class="string">&quot;all_message_exchange&quot;</span>;</span><br><span class="line">            <span class="comment">//交换机类型</span></span><br><span class="line">            String exchangeType=<span class="string">&quot;direct&quot;</span>;</span><br><span class="line">            <span class="comment">//定义一个交换机</span></span><br><span class="line">            channel.exchangeDeclare(exchangeName,exchangeType,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue5&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue6&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue7&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定队列和交换机的关系</span></span><br><span class="line">            channel.queueBind(<span class="string">&quot;queue5&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;queue6&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;queue7&quot;</span>,exchangeName,<span class="string">&quot;order&quot;</span>);</span><br><span class="line">          <span class="comment">//  String queueName = &quot;queue1&quot;;</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String message = <span class="string">&quot;hello kang xiao zhuang&quot;</span>;</span><br><span class="line">            <span class="comment">//发送消息给队列</span></span><br><span class="line">            channel.basicPublish(exchangeName,<span class="string">&quot;order&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到web端创建了交换机和队列，关系也绑定上去了</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_13-19-13.png"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_13-19-56.png" alt="Snipaste_2021-04-17_13-19-56"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_13-20-20.png" alt="Snipaste_2021-04-17_13-20-20"></p>
<p>消费者代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.all;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 代码创建交换机的消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue5&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收到的消息是&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.in.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码都是大同小异，主要是看用什么方式创建和定义交换机，队列</p>
<h1 id="16，Work模式-轮询模式"><a href="#16，Work模式-轮询模式" class="headerlink" title="16，Work模式-轮询模式"></a>16，Work模式-轮询模式</h1><p>当有多个消费者时，消息会被哪个消费者消费呢，主要有两种模式，如何均衡消费者消费的信息多少</p>
<p>1，轮询模式的分发：一个消费者一条，按均分配</p>
<p>2，公平分发：根据消费者的消费能力进行公平分发，处理快处理的多，慢处理的少，按劳分配！</p>
<p><strong>实战模拟</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.lunxun;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            String queueName = <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;hello kang xiao zhuang--&gt;轮询模式&quot;</span>+i;</span><br><span class="line">                <span class="comment">//发送消息给队列</span></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个消费者 同时运行看结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 轮询模式的案例 消费者1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 13:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer1号收到消息是：&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer1号开始接收消息&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.lunxun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 轮询模式的案例 消费者2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 13:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumer2号收到消息是：&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer2号开始接收消息&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_13-49-05.png"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_13-48-58.png" alt="Snipaste_2021-04-17_13-48-58"></p>
<p><strong>总结 ：不会因为服务器的性能而影响消费的多少，都是对等！</strong></p>
<h1 id="17，Work模式-公平模式"><a href="#17，Work模式-公平模式" class="headerlink" title="17，Work模式-公平模式"></a>17，Work模式-公平模式</h1><p>改成手动应答机制，指标设置参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/15 15:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            String queueName = <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            队列名称</span></span><br><span class="line"><span class="comment">            是否要持久化</span></span><br><span class="line"><span class="comment">            排他性</span></span><br><span class="line"><span class="comment">            是否自动删除</span></span><br><span class="line"><span class="comment">            携带附属参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;hello kang xiao zhuang--&gt;公平模式&quot;</span>+i;</span><br><span class="line">                <span class="comment">//发送消息给队列</span></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 公平模式的案例 消费者1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 13:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            <span class="comment">//设定指标的值</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Consumer1号收到消息是：&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer1号开始接收消息&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.rabbitmq.work.fair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Consumer2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 公平模式的案例 消费者2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 13:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接工程</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;192.168.152.130&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//创建Connection</span></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = connectionFactory.newConnection(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">            <span class="comment">//通过连接获得通道Channel</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//通过交换机创建 声明队列 绑定关系 路由key 发送消息 和接收消息</span></span><br><span class="line">            <span class="comment">//设定指标的值</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            Channel finalChannel = channel;</span><br><span class="line">            channel.basicConsume(<span class="string">&quot;queue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s, Delivery delivery)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Consumer2号收到消息是：&quot;</span> + <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        finalChannel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接受失败...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer2号开始接收消息&quot;</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="18，RabbitMQ应用场景"><a href="#18，RabbitMQ应用场景" class="headerlink" title="18，RabbitMQ应用场景"></a>18，RabbitMQ应用场景</h1><p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_14-26-09.png"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_14-27-07.png" alt="Snipaste_2021-04-17_14-27-07"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_14-28-53.png" alt="Snipaste_2021-04-17_14-28-53"></p>
<p><strong>好处：</strong></p>
<ul>
<li>完全解耦，用MQ建立桥接</li>
<li>有独立的线程池和运行模型</li>
<li>出现了消息可能会丢失，MQ有持久化功能</li>
<li>如何保证消息的可靠性，死信队列和消息转移功能</li>
<li>如果服务器承载不了，你需要自己去写高可用，HA镜像模型高可用</li>
</ul>
<p>按照上面约定，用户的响应时间相当于是订单信息的写入数据库的时间，也就是50毫秒，注册邮件，发送消息写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，架构改变后，比串行提高3倍，并行提高2倍</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_14-30-05.png" alt="Snipaste_2021-04-17_14-30-05"></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_14-30-21.png" alt="Snipaste_2021-04-17_14-30-21"></p>
<p>场景</p>
<ul>
<li>流量的削峰</li>
<li>分布式事务的可靠消费和可靠生产</li>
<li>索引，缓存，静态化处理的数据同步</li>
<li>流量监控</li>
<li>日志监控</li>
<li>下单，订单分发，抢票</li>
</ul>
<h1 id="19，SpringBoot整合RabbitMQ"><a href="#19，SpringBoot整合RabbitMQ" class="headerlink" title="19，SpringBoot整合RabbitMQ"></a>19，SpringBoot整合RabbitMQ</h1><p>在Spring项目中，可以使用Spring-Rabbit去操作RabbitMQ<br><a href="https://github.com/spring-projects/spring-amqp">https://github.com/spring-projects/spring-amqp</a></p>
<p>尤其是在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。</p>
<p><em>一般在开发过程中</em>：</p>
<p><strong>生产者工程：</strong></p>
<ol>
<li><p>application.yml文件配置RabbitMQ相关信息；</p>
</li>
<li><p>在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定</p>
</li>
<li><p>注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机</p>
</li>
</ol>
<p><strong>消费者工程：</strong></p>
<ol>
<li><p>application.yml文件配置RabbitMQ相关信息</p>
</li>
<li><p>创建消息处理类，用于接收队列中的消息并进行处理</p>
</li>
</ol>
<p>新建一个模块 导入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbitmq服务</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.152</span><span class="number">.130</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure>



<p>创建业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.springboot_rabbitmq.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> OrderService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 业务层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 14:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟用户下单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeOrder</span><span class="params">(String userid,String productid,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据商品id查询库存是否充足</span></span><br><span class="line">        String orderId = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//保存订单</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单生产成功&quot;</span>+orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过MQ来完成消息的分发</span></span><br><span class="line">        String exchangeName=<span class="string">&quot;fanout_order_exchange&quot;</span>;</span><br><span class="line">        String routingKey=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName,routingKey,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写配置类 定义交换机和队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.springboot_rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> RabbitMQConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> rabbitmq的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 14:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明注册fanout模式的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;fanout_order_exchange&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列sms.fanout.queue email.fanout.queue duanxin.fanout.queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">smsQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;sms.fanout.queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">duanxinQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;duanxin.fanout.queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">emailQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;email.fanout.queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">smsBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(smsQueue()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">duanxinBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(duanxinQueue()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">emailBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(emailQueue()).to(fanoutExchange());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建三个消费者 类上添加注解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.springboot_rabbitmq.service.fanout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> FanoutDuanXinConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> FanoutDuanXinConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 15:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;duanxin.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutDuanXinConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dunaxin fanout --- 接受到了订单消息是：-&gt;&quot;</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.springboot_rabbitmq.service.fanout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> FanoutEmailConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> FanoutEmailConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 15:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;email.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutEmailConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;email fanout --- 接受到了订单消息是：-&gt;&quot;</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.springboot_rabbitmq.service.fanout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> FanoutSMSConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> FanoutSMSConsumer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/17 15:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;sms.fanout.queue&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutSMSConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sms fanout --- 接受到了订单消息是：-&gt;&quot;</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-17_15-13-10.png"></p>
<p><strong>看到消息被创建而且被消费</strong></p>
<h1 id="20，RabbitMQ模式总结"><a href="#20，RabbitMQ模式总结" class="headerlink" title="20，RabbitMQ模式总结"></a>20，RabbitMQ模式总结</h1><p>RabbitMQ工作模式：<br><strong>1、简单模式 HelloWorld</strong><br>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p>
<p><strong>2、工作队列模式 Work Queue</strong><br>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p>
<p><strong>3、发布订阅模式 Publish/subscribe</strong><br>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p>
<p><strong>4、路由模式 Routing</strong><br>需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
<p><strong>5、通配符模式 Topic</strong><br>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
<h1 id="21，RabbitMQ高级特性"><a href="#21，RabbitMQ高级特性" class="headerlink" title="21，RabbitMQ高级特性"></a>21，RabbitMQ高级特性</h1><h2 id="21-1-消息的可靠投递"><a href="#21-1-消息的可靠投递" class="headerlink" title="21.1 消息的可靠投递"></a>21.1 消息的可靠投递</h2><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p>
<ul>
<li><p>confirm 确认模式</p>
</li>
<li><p>return 退回模式</p>
</li>
</ul>
<p>rabbitmq 整个消息投递的路径为：</p>
<p>producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer</p>
<ul>
<li><p>消息从 producer 到 exchange 则会返回一个 confirmCallback 。</p>
</li>
<li><p>消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback 。</p>
</li>
</ul>
<p>我们将利用这两个 callback 控制消息的可靠性投递</p>
<h2 id="21-2-Consumer-Ack"><a href="#21-2-Consumer-Ack" class="headerlink" title="21.2 Consumer Ack"></a>21.2 Consumer Ack</h2><p>ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。</p>
<p>有三种确认方式：</p>
<ul>
<li><p>自动确认：acknowledge=”none”</p>
</li>
<li><p>手动确认：acknowledge=”manual”</p>
</li>
<li><p>根据异常情况确认：acknowledge=”auto”）</p>
</li>
</ul>
<p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p>
<h2 id="21-3-TTL"><a href="#21-3-TTL" class="headerlink" title="21.3 TTL"></a>21.3 TTL</h2><ul>
<li><p>TTL 全称 Time To Live（存活时间/过期时间）。</p>
</li>
<li><p>当消息到达存活时间后，还没有被消费，会被自动清除。</p>
</li>
<li><p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间</p>
</li>
</ul>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-18_13-52-32.png"></p>
<p><strong>小结</strong></p>
<ul>
<li><p>设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。</p>
</li>
<li><p>设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。</p>
</li>
<li><p>如果两者都进行了设置，以时间短的为准。</p>
</li>
</ul>
<h2 id="21-4-死信队列"><a href="#21-4-死信队列" class="headerlink" title="21.4 死信队列"></a>21.4 死信队列</h2><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-18_13-54-09.png"></p>
<p><strong>消息成为死信的三种情况：</strong></p>
<ol>
<li><p>队列消息长度到达限制；</p>
</li>
<li><p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；</p>
</li>
<li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p>
</li>
</ol>
<p><strong>队列绑定死信交换机：</strong></p>
<p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-18_13-55-53.png"></p>
<h2 id="21-5-日志监控"><a href="#21-5-日志监控" class="headerlink" title="21.5 日志监控"></a>21.5 日志监控</h2><p>配置详解见</p>
<p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p>
<h3 id="21-5-1-rabbitmqctl管理和监控"><a href="#21-5-1-rabbitmqctl管理和监控" class="headerlink" title="21.5.1 rabbitmqctl管理和监控"></a>21.5.1 <strong>rabbitmqctl管理和监控</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看队列</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_queues</span></span><br><span class="line"></span><br><span class="line">查看exchanges</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_exchanges</span></span><br><span class="line"></span><br><span class="line">查看用户</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_users</span></span><br><span class="line"></span><br><span class="line">查看连接</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_connections</span></span><br><span class="line"></span><br><span class="line">查看消费者信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_consumers</span></span><br><span class="line"></span><br><span class="line">查看环境变量</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl environment</span></span><br><span class="line"></span><br><span class="line">查看未被确认的队列</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_queues  name messages_unacknowledged</span></span><br><span class="line"></span><br><span class="line">查看单个队列的内存使用</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_queues name memory</span></span><br><span class="line"></span><br><span class="line">查看准备就绪的队列</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbitmqctl list_queues name messages_ready</span></span><br></pre></td></tr></table></figure>



<h1 id="22，RabbitMQ应用问题"><a href="#22，RabbitMQ应用问题" class="headerlink" title="22，RabbitMQ应用问题"></a>22，RabbitMQ应用问题</h1><ol>
<li>消息可靠性保障</li>
</ol>
<ul>
<li>消息补偿机制</li>
</ul>
<ol start="2">
<li>消息幂等性保障</li>
</ol>
<ul>
<li>乐观锁解决方案</li>
</ul>
<h2 id="22-1-消息可靠性保障"><a href="#22-1-消息可靠性保障" class="headerlink" title="22.1 消息可靠性保障"></a>22.1 <strong>消息可靠性保障</strong></h2><p><strong>消息补偿</strong></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-18_13-59-14.png"></p>
<h2 id="22-2-消息幂等性保障"><a href="#22-2-消息幂等性保障" class="headerlink" title="22.2 消息幂等性保障"></a>22.2 消息幂等性保障</h2><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p>
<p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。</p>
<p><strong>乐观锁机制</strong></p>
<p><img src="https://gitee.com/zhuang-kang/note-picture/raw/master/RabbitMQ%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/RabbitMQSnipaste_2021-04-18_14-00-32.png"></p>
<h1 id="23，RabbitMQ集群搭建"><a href="#23，RabbitMQ集群搭建" class="headerlink" title="23，RabbitMQ集群搭建"></a>23，RabbitMQ集群搭建</h1><h2 id="此章节后续补上！"><a href="#此章节后续补上！" class="headerlink" title="此章节后续补上！"></a>此章节后续补上！</h2>]]></content>
  </entry>
</search>
