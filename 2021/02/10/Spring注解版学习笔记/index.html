<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring注解版学习笔记 | 康小庄的博客</title><meta name="keywords" content="Spring"><meta name="author" content="康小庄"><meta name="copyright" content="康小庄"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring注解版学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring注解版学习笔记">
<meta property="og:url" content="http://example.com/2021/02/10/Spring%E6%B3%A8%E8%A7%A3%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="康小庄的博客">
<meta property="og:description" content="Spring注解版学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/60eaabe75132923bf8395d69.jpg">
<meta property="article:published_time" content="2021-02-10T08:38:03.000Z">
<meta property="article:modified_time" content="2021-07-11T08:31:24.303Z">
<meta property="article:author" content="康小庄">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/60eaabe75132923bf8395d69.jpg"><link rel="shortcut icon" href="/img/2.png"><link rel="canonical" href="http://example.com/2021/02/10/Spring%E6%B3%A8%E8%A7%A3%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring注解版学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-11 16:31:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw far fa-image"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline"><i class="fa-fw fas fa-link"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/60eaabe75132923bf8395d69.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">康小庄的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw far fa-image"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline"><i class="fa-fw fas fa-link"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring注解版学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-10T08:38:03.000Z" title="发表于 2021-02-10 16:38:03">2021-02-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-11T08:31:24.303Z" title="更新于 2021-07-11 16:31:24">2021-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring注解版学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring注解版学习笔记"><a href="#Spring注解版学习笔记" class="headerlink" title="Spring注解版学习笔记"></a>Spring注解版学习笔记</h1><p><strong>学习地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy?p=1">https://www.bilibili.com/video/BV1gW411W7wy?p=1</a></strong></p>
<h1 id="一，IOC"><a href="#一，IOC" class="headerlink" title="一，IOC"></a>一，IOC</h1><h2 id="1-使用-Configuration和-Bean给容器中注册组件"><a href="#1-使用-Configuration和-Bean给容器中注册组件" class="headerlink" title="1. 使用@Configuration和@Bean给容器中注册组件"></a>1. 使用@Configuration和@Bean给容器中注册组件</h2><h3 id="1-1-配置文件方式"><a href="#1-1-配置文件方式" class="headerlink" title="1.1 配置文件方式"></a>1.1 配置文件方式</h3><ul>
<li>新建Maven工程</li>
<li>导入依赖</li>
<li>创建工程目录</li>
<li>编写目录</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建 beans,xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhuang.dao.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhuangkang&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>目录</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr3BF"><img src="https://z3.ax1x.com/2021/07/06/RTr3BF.png" alt="RTr3BF.png"></a></p>
<p><strong>Person</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 12:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MainTest</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuang.config.MainConfig;</span><br><span class="line"><span class="keyword">import</span> com.zhuang.dao.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MainTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 12:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        Person bean = applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrQXT"><img src="https://z3.ax1x.com/2021/07/06/RTrQXT.png" alt="RTrQXT.png"></a></p>
<h3 id="1-2-注解方式"><a href="#1-2-注解方式" class="headerlink" title="1.2 注解方式"></a>1.2 注解方式</h3><p><strong>MainConfig</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuang.dao.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MainConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 13:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.zhuang&quot;,includeFilters =</span></span><br><span class="line"><span class="meta">        &#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MyTypeFliter.class)&#125;)</span>  <span class="comment">//包扫描注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中注册bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;康康&quot;</span>,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MainTest</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuang.config.MainConfig;</span><br><span class="line"><span class="keyword">import</span> com.zhuang.dao.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MainTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 12:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注解式</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">        Person bean = applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr1nU"><img src="https://z3.ax1x.com/2021/07/06/RTr1nU.png" alt="RTr1nU.png"></a></p>
<p>通过XML配置文件和注解这两种方式都可以将JavaBean注入到Spring的IOC容器中。那么，使用注解将JavaBean注入到IOC容器中时，使用的bean的名称又是什么呢？我们可以在MainTest类的main方法中添加如下代码来获取Person这个类型的组件在IOC容器中的名字。</p>
<p>在<strong>MainTest</strong>类中添加下列代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrK10"><img src="https://z3.ax1x.com/2021/07/06/RTrK10.png" alt="RTrK10.png"></a></p>
<p><strong>使用注解注入JavaBean时，bean在IOC容器中的名称就是使用@Bean注解标注的方法名称。</strong></p>
<p>注解Bean中赋值也可以</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrMcV"><img src="https://z3.ax1x.com/2021/07/06/RTrMcV.png" alt="RTrMcV.png"></a></p>
<p><strong>总结</strong></p>
<p> <strong>我们在使用注解方式向Spring的IOC容器中注入JavaBean时，如果没有在@Bean注解中明确指定bean的名称，那么就会使用当前方法的名称来作为bean的名称；如果在@Bean注解中明确指定了bean的名称，那么就会使用@Bean注解中指定的名称来作为bean的名称。</strong></p>
<h2 id="2-使用-ComponentScan自动扫描组件并指定扫描规则"><a href="#2-使用-ComponentScan自动扫描组件并指定扫描规则" class="headerlink" title="2. 使用@ComponentScan自动扫描组件并指定扫描规则"></a>2. 使用@ComponentScan自动扫描组件并指定扫描规则</h2><p>凡是在指定的包或其子包中的类上标注了@Repository、@Service、@Controller、@Component注解的类都会被扫描到，并将这个类注入到Spring容器中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    包扫描组件 @Service @Repository @Controller 都会扫描到--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zhuang&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>分别创建BookDao、BookService以及BookController这三个类，并在这三个类中分别添加@Repository、@Service、@Controller注解</strong></p>
<p><strong>BookDao</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> BookDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> BookDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 13:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BookService</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> BookService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> BookService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 13:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BookController</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> BookController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> BookController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 13:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在MainTest中添加下列代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr874"><img src="https://z3.ax1x.com/2021/07/06/RTr874.png" alt="RTr874.png"></a></p>
<p>可以看到，除了输出我们自己创建的bean的名称之外，也输出了Spring内部使用的一些重要的bean的名称。</p>
<h3 id="2-1-ComponentScan-注解"><a href="#2-1-ComponentScan-注解" class="headerlink" title="2.1 @ComponentScan 注解"></a>2.1 @ComponentScan 注解</h3><p><strong>扫描时排除注解标注的类</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrJAJ"><img src="https://z3.ax1x.com/2021/07/06/RTrJAJ.png" alt="RTrJAJ.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter[] includeFilters()  <span class="comment">//包括哪些规则</span></span><br><span class="line"></span><br><span class="line">Filter[] excludeFilters()  <span class="comment">//排除哪些规则</span></span><br></pre></td></tr></table></figure>



<p><strong>自定义过滤器</strong></p>
<p><strong>MyTypeFliter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FilterType.ASSIGNABLE_TYPE <span class="comment">//按照给定的类型进行包含或者排除</span></span><br><span class="line">FilterType.ANNOTATION <span class="comment">//注解形式</span></span><br><span class="line">FilterType.REGE <span class="comment">//按照正则表达式进行包含或者排除</span></span><br><span class="line">metadataReader <span class="comment">//读取当前正在扫描的类信息</span></span><br><span class="line">metadataReaderFactory <span class="comment">//可以获取到任何其他的信息</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.ClassMetadata;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.filter.TypeFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MyTypeFliter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自定义过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 13:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFliter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前的注解的信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//获取当前正在扫描的类的信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">//获取当前类的资源</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line">        String className=classMetadata.getClassName();</span><br><span class="line">        System.out.println(<span class="string">&quot;className--&gt;&quot;</span>+className);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MainConfig 中添加下列代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.zhuang&quot;,includeFilters=</span></span><br><span class="line"><span class="meta">        &#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = MyTypeFliter.class)&#125;</span></span><br><span class="line"><span class="meta">        )</span>  <span class="comment">//包扫描注解</span></span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTra1x"><img src="https://z3.ax1x.com/2021/07/06/RTra1x.png" alt="RTra1x.png"></a></p>
<p><strong>小结</strong></p>
<p>我们可以使用@ComponentScan注解来指定Spring扫描哪些包，可以使用excludeFilters()方法来指定扫描时排除哪些组件，也可以使用includeFilters()方法来指定扫描时只包含哪些组件。当使用includeFilters()方法指定只包含哪些组件时，需要禁用掉默认的过滤规则</p>
<h2 id="3-使用-Scope注解设置组件的作用域"><a href="#3-使用-Scope注解设置组件的作用域" class="headerlink" title="3. 使用@Scope注解设置组件的作用域"></a>3. 使用@Scope注解设置组件的作用域</h2><p>Spring容器中的组件默认是单例的，在Spring启动时就会实例化并初始化这些对象，并将其放到Spring容器中，之后，每次获取对象时，直接从Spring容器中获取，而不再创建对象。如果每次从Spring容器中获取对象时，都要创建一个新的实例对象，那么该如何处理呢？此时就需要使用@Scope注解来设置组件的作用域了</p>
<h3 id="3-1-Scope注解概述"><a href="#3-1-Scope注解概述" class="headerlink" title="3.1@Scope注解概述"></a>3.1@Scope注解概述</h3><p><strong>从@Scope注解类的源码中可以看出，在@Scope注解中可以设置如下值：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableBeanFactory#SCOPE_PROTOTYPE</span><br><span class="line">ConfigurableBeanFactory#SCOPE_SINGLETON</span><br><span class="line">org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span><br><span class="line">org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrU91"><img src="https://z3.ax1x.com/2021/07/06/RTrU91.png" alt="RTrU91.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrthR"><img src="https://z3.ax1x.com/2021/07/06/RTrthR.png" alt="RTrthR.png"></a></p>
<h3 id="3-2-单实例bean作用域"><a href="#3-2-单实例bean作用域" class="headerlink" title="3.2 单实例bean作用域"></a>3.2 单实例bean作用域</h3><p>测试类中测试是否为单例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">        Person bean = applicationContext.getBean(Person.class);</span><br><span class="line">        Person bean1 = applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean==bean1); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>对象在Spring容器中默认是单实例的，Spring容器在启动时就会将实例对象加载到Spring容器中，之后，每次从Spring容器中获取实例对象，都是直接将对象返回，而不必再创建新的实例对象了</strong></p>
<h3 id="3-3-多实例bean作用域"><a href="#3-3-多实例bean作用域" class="headerlink" title="3.3 多实例bean作用域"></a>3.3 多实例bean作用域</h3><p>修改@Scope注解为 （”prototype”）</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrdc6"><img src="https://z3.ax1x.com/2021/07/06/RTrdc6.png" alt="RTrdc6.png"></a></p>
<p>再次测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">        Person bean = applicationContext.getBean(Person.class);</span><br><span class="line">        Person bean1 = applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(bean==bean1); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h3 id="3-4-单实例bean注意的事项"><a href="#3-4-单实例bean注意的事项" class="headerlink" title="3.4 单实例bean注意的事项"></a>3.4 单实例bean注意的事项</h3><p>单实例bean是整个应用所共享的，所以需要考虑到线程安全问题，SpringMVC中的Controller默认是单例的，有些开发者在Controller中创建了一些变量，那么这些变量实际上就变成共享的了，Controller又可能会被很多线程同时访问，这些线程并发去修改Controller中的共享变量，此时很有可能会出现数据错乱的问题，所以使用的时候需要特别注意。</p>
<h3 id="3-5-多实例bean注意的事项"><a href="#3-5-多实例bean注意的事项" class="headerlink" title="3.5 多实例bean注意的事项"></a>3.5 多实例bean注意的事项</h3><p>多实例bean每次获取的时候都会重新创建，如果这个bean比较复杂，创建时间比较长，那么就会影响系统的性能，因此这个地方需要注意点。</p>
<h2 id="4-懒加载"><a href="#4-懒加载" class="headerlink" title="4. 懒加载"></a>4. 懒加载</h2><p>懒加载就是Spring容器启动的时候，先不创建对象，在第一次使用（获取）bean的时候再来创建对象，并进行一些初始化</p>
<p>测试一把 没有加入懒加载@Lazy 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;kangxiaozhuang&quot;)</span> <span class="comment">//给容器中注册bean</span></span><br><span class="line">    <span class="meta">@Scope</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给容器添加Bean对象...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;康康&quot;</span>,<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;sources&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">        Person bean = applicationContext.getBean(Person.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;IOC容器创建完成&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrwjK"><img src="https://z3.ax1x.com/2021/07/06/RTrwjK.png" alt="RTrwjK.png"></a></p>
<p><strong>可以看到，单实例bean在Spring容器启动的时候就会被创建，并且还加载到Spring容器中去了。</strong></p>
<p><strong>懒加载模式</strong></p>
<p>添加注解@Lazy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line">   <span class="meta">@Bean(&quot;kangxiaozhuang&quot;)</span> <span class="comment">//给容器中注册bean</span></span><br><span class="line">   <span class="meta">@Scope</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;给容器添加Bean对象...&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;康康&quot;</span>,<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;sources&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;IOC容器创建完成&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrBnO"><img src="https://z3.ax1x.com/2021/07/06/RTrBnO.png" alt="RTrBnO.png"></a></p>
<p><strong>此时只是打印出一条信息，说明此时只创建了IOC容器，而并没有创建bean对象</strong></p>
<p>使用@Lazy注解标注后，单实例bean对象只是在第一次从Spring容器中获取时被创建，以后每次获取bean对象时，直接返回创建好的对象</p>
<p>小结</p>
<p><strong>懒加载，也称延时加载，仅针对单实例bean生效。 单实例bean是在Spring容器启动的时候加载的，添加@Lazy注解后就会延迟加载，在Spring容器启动的时候并不会加载，而是在第一次使用此bean的时候才会加载，但当你多次获取bean的时候并不会重复加载，只是在第一次获取的时候才会加载，这不是延迟加载的特性，而是单实例bean的特性</strong></p>
<h2 id="5-按照条件向Spring容器中注册Bean"><a href="#5-按照条件向Spring容器中注册Bean" class="headerlink" title="5. 按照条件向Spring容器中注册Bean"></a>5. 按照条件向Spring容器中注册Bean</h2><ul>
<li><p>当bean是单实例，并且没有设置懒加载时，<strong>Spring容器启动时，就会实例化bean</strong>，并将bean注册到IOC容器中，以后每次从IOC容器中获取bean时，<strong>直接返回IOC容器中的bean，而不用再创建新的bean了。</strong></p>
</li>
<li><p>若bean是单实例，并且使用@Lazy注解设置了懒加载，则Spring容器启动时，不会立即实例化bean，自然就不会将bean注册到IOC容器中了，<strong>只有第一次获取bean的时候，才会实例化bean，并且将bean注册到IOC容器中。</strong></p>
</li>
<li><p>若bean是多实例，则Spring容器启动时，不会实例化bean，也不会将bean注册到IOC容器中，<strong>只是在以后每次从IOC容器中获取bean的时候，都会创建一个新的bean返回。</strong></p>
</li>
</ul>
<h3 id="5-1-Conditional注解"><a href="#5-1-Conditional注解" class="headerlink" title="5.1 @Conditional注解"></a>5.1 @Conditional注解</h3><p>可以按照一定的条件进行判断，满足条件向容器中注册bean，不满足条件就不向容器中注册bean</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrDBD"><img src="https://z3.ax1x.com/2021/07/06/RTrDBD.png" alt="RTrDBD.png"></a></p>
<p><strong>从@Conditional注解的源码来看，@Conditional注解不仅可以添加到类上，也可以添加到方法上。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrrHe"><img src="https://z3.ax1x.com/2021/07/06/RTrrHe.png" alt="RTrrHe.png"></a></p>
<p><strong>所含方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取到bean的创建工厂（能获取到IOC容器使用到的BeanFactory，它就是创建对象以及进行装配的工厂）</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">      <span class="comment">// 2. 获取到类加载器</span></span><br><span class="line">      ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">      <span class="comment">// 3. 获取当前环境信息，它里面就封装了我们这个当前运行时的一些信息，包括环境变量，以及包括虚拟机的一些变量</span></span><br><span class="line">      Environment environment = context.getEnvironment();</span><br><span class="line">      <span class="comment">// 4. 获取到bean定义的注册类</span></span><br><span class="line">      BeanDefinitionRegistry registry = context.getRegistry();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">点进ConditionContext参数中看源码 </span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTryAH"><img src="https://z3.ax1x.com/2021/07/06/RTryAH.png" alt="RTryAH.png"></a></p>
<p><strong>所有方法</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr6Nd"><img src="https://z3.ax1x.com/2021/07/06/RTr6Nd.png" alt="RTr6Nd.png"></a></p>
<p>其他注解拓展</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrc4A"><img src="https://z3.ax1x.com/2021/07/06/RTrc4A.png" alt="RTrc4A.png"></a></p>
<h2 id="6-使用-Import注解给容器中导入一个组件"><a href="#6-使用-Import注解给容器中导入一个组件" class="headerlink" title="6. 使用@Import注解给容器中导入一个组件"></a>6. 使用@Import注解给容器中导入一个组件</h2><h3 id="6-1-注册bean的方式"><a href="#6-1-注册bean的方式" class="headerlink" title="6.1 注册bean的方式"></a>6.1 注册bean的方式</h3><p>向Spring容器中注册bean通常有以下几种方式：</p>
<p>包扫描+给组件标注注解（@Controller、@Servcie、@Repository、@Component），但这种方式比较有局限性，局限于我们自己写的类<br>@Bean注解，通常用于导入第三方包中的组件<br>@Import注解，快速向Spring容器中导入一个组件</p>
<h3 id="6-2-Import注解概述"><a href="#6-2-Import注解概述" class="headerlink" title="6.2 @Import注解概述"></a>6.2 @Import注解概述</h3><p>Spring 3.0之前，创建bean可以通过XML配置文件与扫描特定包下面的类来将类注入到Spring IOC容器内。而在Spring 3.0之后提供了JavaConfig的方式，也就是将IOC容器里面bean的元信息以Java代码的方式进行描述，然后我们可以通过@Configuration与@Bean这两个注解配合使用来将原来配置在XML文件里面的bean通过Java代码的方式进行描述。</p>
<h3 id="6-3-Import注解的使用方式"><a href="#6-3-Import注解的使用方式" class="headerlink" title="6.3 @Import注解的使用方式"></a>6.3 @Import注解的使用方式</h3><p><strong>@Import注解的三种用法主要包括：</strong></p>
<ol>
<li>直接填写class数组的方式</li>
<li><strong>ImportSelector接口的方式</strong></li>
<li>ImportBeanDefinitionRegistrar接口方式，即手工注册bean到容器中</li>
</ol>
<p>创建一个Student类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一把</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrWgP"><img src="https://z3.ax1x.com/2021/07/06/RTrWgP.png" alt="RTrWgP.png"></a></p>
<p>添加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(Student.class)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrR3t"><img src="https://z3.ax1x.com/2021/07/06/RTrR3t.png" alt="RTrR3t.png"></a></p>
<p><strong>@Import 支持 一次性导入多个类 用,分隔</strong></p>
<h2 id="7-在-Import注解中使用ImportSelector接口导入bean"><a href="#7-在-Import注解中使用ImportSelector接口导入bean" class="headerlink" title="7. 在@Import注解中使用ImportSelector接口导入bean"></a>7. 在@Import注解中使用ImportSelector接口导入bean</h2><p>源码</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr29I"><img src="https://z3.ax1x.com/2021/07/06/RTr29I.png" alt="RTr29I.png"></a></p>
<ul>
<li><p>其主要作用是收集需要导入的配置类，<strong>selectImports()方法的返回值就是我们向Spring容器中导入的类的全类名。</strong>如果该接口的实现类同时实现EnvironmentAware，BeanFactoryAware，BeanClassLoaderAware或者ResourceLoaderAware，那么在调用其selectImports()方法之前先调用上述接口中对应的方法，<strong>如果需要在所有的@Configuration处理完再导入时，那么可以实现DeferredImportSelector接口。</strong></p>
</li>
<li><p>在ImportSelector接口的selectImports()方法中，<strong>存在一个AnnotationMetadata类型的参数，这个参数能够获取到当前标注@Import注解的类的所有注解信息，也就是说不仅能获取到@Import注解里面的信息，还能获取到其他注解的信息。</strong></p>
</li>
</ul>
<h2 id="8-在-Import注解中使用ImportBeanDefinitionRegistrar向容器中注册bean"><a href="#8-在-Import注解中使用ImportBeanDefinitionRegistrar向容器中注册bean" class="headerlink" title="8. 在@Import注解中使用ImportBeanDefinitionRegistrar向容器中注册bean"></a>8. 在@Import注解中使用ImportBeanDefinitionRegistrar向容器中注册bean</h2><p>源码</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr4u8"><img src="https://z3.ax1x.com/2021/07/06/RTr4u8.png" alt="RTr4u8.png"></a></p>
<p>使用步骤</p>
<p>ImportBeanDefinitionRegistrar需要配合@Configuration和@Import这俩注解，其中，@Configuration注解定义Java格式的Spring配置文件，@Import注解导入实现了ImportBeanDefinitionRegistrar接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Student.class, MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义 MyImportBeanDefinitionRegistrar</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuang.bean.School;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotationMetadata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MyImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> MyImportBeanDefinitionRegistrar 实现 ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 21:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment">     * BeanDefinitionRegistry：BeanDefinition注册类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们可以通过调用BeanDefinitionRegistry接口中的registerBeanDefinition方法，手动注册所有需要添加到容器中的bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> definition1 = registry.containsBeanDefinition(<span class="string">&quot;com.zhuang.bean.Student&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">&quot;com.zhuang.bean.Teacher&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (definition1 &amp;&amp; definition2)&#123;</span><br><span class="line">            <span class="comment">//指定bean的定义信息 包括类型 作用域</span></span><br><span class="line">            <span class="comment">//RootBeanDefinition 是BeanDefinition接口的子实现类</span></span><br><span class="line">            BeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(School.class);</span><br><span class="line">            <span class="comment">//注册一个bean 指定其名称</span></span><br><span class="line">            registry.registerBeanDefinition(<span class="string">&quot;school&quot;</span>,rootBeanDefinition);</span><br><span class="line">			</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**输出 school **</p>
<p>说明Spring容器中已经成功注册了以school命名的bean</p>
<h2 id="9-使用FactoryBean向Spring容器中注册bean"><a href="#9-使用FactoryBean向Spring容器中注册bean" class="headerlink" title="9. 使用FactoryBean向Spring容器中注册bean"></a>9. 使用FactoryBean向Spring容器中注册bean</h2><p>一般情况下，<strong>Spring是通过反射机制利用bean的class属性指定实现类来实例化bean的</strong>。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，那么则需要在标签中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可以得到一个更加简单的方案。<strong>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑。</strong></p>
<p><strong>FactoryBean 源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="comment">//返回由FactoryBean创建的bean实例，如果isSingleton()返回true，那么该实例会放到Spring容器中单实例缓存池中</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> <span class="comment">//返回由FactoryBean创建的bean实例的作用域是singleton还是prototype</span></span></span><br><span class="line"><span class="function">Class <span class="title">getObjectType</span><span class="params">()</span> <span class="comment">//返回FactoryBean创建的bean实例的类型</span></span></span><br></pre></td></tr></table></figure>

<p><strong>创建SchoolFactory 实现FactoryBean接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> SchoolFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   SchoolFactory 实现FactoryBean接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 21:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchoolFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">School</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    T 泛型 指定我们创建什么对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> School <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SchoolFactory--&gt;getObject()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> School();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="comment">//返回对象类型</span></span><br><span class="line">        <span class="keyword">return</span> School.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    是否为单例 true 是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SchoolFactory <span class="title">schoolFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SchoolFactory();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrIHg"><img src="https://z3.ax1x.com/2021/07/06/RTrIHg.png" alt="RTrIHg.png"></a></p>
<p>测试类中添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean1 = applicationContext.getBean(<span class="string">&quot;schoolFactory&quot;</span>);</span><br><span class="line">        System.out.println(bean1.getClass());</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrTEQ"><img src="https://z3.ax1x.com/2021/07/06/RTrTEQ.png" alt="RTrTEQ.png"></a></p>
<p><strong>虽然我在代码中使用@Bean注解注入的是SchoolFactory对象，但是实际上从Spring容器中获取到的bean对象却是调用SchoolFactory类中的getObject()方法获取到的School对象</strong></p>
<p>在SchoolFactory类中，我们将School对象设置为单实例bean，即让isSingleton()方法返回true。接下来，我们在测试类中的testImport()方法里面多次获取School对象，并判断一下多次获取的对象是否为同一对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object bean1 = applicationContext.getBean(<span class="string">&quot;schoolFactory&quot;</span>);</span><br><span class="line">        Object bean2 = applicationContext.getBean(<span class="string">&quot;schoolFactory&quot;</span>);</span><br><span class="line">        System.out.println(bean1==bean2);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTr7Nj"><img src="https://z3.ax1x.com/2021/07/06/RTr7Nj.png" alt="RTr7Nj.png"></a></p>
<p><strong>如何在Spring容器中获取到FactoryBean对象本身呢？</strong></p>
<p>只需要在获取工厂Bean本身时，在id前面加上&amp;符号即可，例如&amp;schoolFactoryBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean3 = applicationContext.getBean(<span class="string">&quot;&amp;schoolFactory&quot;</span>);</span><br><span class="line">       System.out.println(bean3.getClass());</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrH4s"><img src="https://z3.ax1x.com/2021/07/06/RTrH4s.png" alt="RTrH4s.png"></a></p>
<p><strong>进入BeanFactory接口中寻找答案</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrqCn"><img src="https://z3.ax1x.com/2021/07/06/RTrqCn.png" alt="RTrqCn.png"></a></p>
<h2 id="10-使用-Bean注解指定初始化和销毁的方法"><a href="#10-使用-Bean注解指定初始化和销毁的方法" class="headerlink" title="10. 使用@Bean注解指定初始化和销毁的方法"></a>10. 使用@Bean注解指定初始化和销毁的方法</h2><h3 id="10-1bean的生命周期"><a href="#10-1bean的生命周期" class="headerlink" title="10.1bean的生命周期"></a>10.1bean的生命周期</h3><p>通常意义上讲的bean的生命周期，指的是bean从创建到初始化，经过一系列的流程，最终销毁的过程。只不过，在Spring中，bean的生命周期是由Spring容器来管理的。<strong>在Spring中，我们可以自己来指定bean的初始化和销毁的方法。我们指定了bean的初始化和销毁方法之后，当容器在bean进行到当前生命周期的阶段时，会自动调用我们自定义的初始化和销毁方法。</strong></p>
<h3 id="10-2-如何定义初始化和销毁方法？"><a href="#10-2-如何定义初始化和销毁方法？" class="headerlink" title="10.2 如何定义初始化和销毁方法？"></a>10.2 如何定义初始化和销毁方法？</h3><p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zhuang.bean.Person&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhaungkang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在我们自己写的Person类中，需要存在init()方法和destroy()方法。而且Spring中还规定，这里的init()方法和destroy()方法必须是无参方法，但可以抛出异常。</p>
<p>新建Car类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.config;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Car</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汽车类 bean的生命周期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car 创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加@Bean注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试一把</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrL3q"><img src="https://z3.ax1x.com/2021/07/06/RTrL3q.png" alt="RTrL3q.png"></a></p>
<p>可以看到，在Spring容器创建完成时，会自动调用单实例bean的构造方法，对单实例bean进行了实例化操作。</p>
<p><strong>总之，对于单实例bean来说，会在Spring容器启动的时候创建对象；对于多实例bean来说，会在每次获取bean的时候创建对象。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrXvV"><img src="https://z3.ax1x.com/2021/07/06/RTrXvV.png" alt="RTrXvV.png"></a></p>
<h3 id="10-3-指定初始化和销毁方法的使用场景"><a href="#10-3-指定初始化和销毁方法的使用场景" class="headerlink" title="10.3 指定初始化和销毁方法的使用场景"></a>10.3 指定初始化和销毁方法的使用场景</h3><p>一个典型的使用场景就是对于数据源的管理。例如，在配置数据源时，在初始化的时候，会对很多的数据源的属性进行赋值操作；在销毁的时候，我们需要对数据源的连接等信息进行关闭和清理。这个时候，我们就可以在自定义的初始化和销毁方法中来做这些事情了！</p>
<ul>
<li>初始化和销毁方法调用的时机<ul>
<li>初始化方法和销毁方法是在什么时候被调用的啊？</li>
</ul>
</li>
</ul>
<p>bean对象的初始化方法调用的时机：</p>
<ul>
<li>对象创建完成，如果对象中存在一些属性，并且这些属性也都赋好值之后，那么就会调用bean的初始化方法。对于单实例bean来说，在Spring容器创建完成后，Spring容器会自动调用bean的初始化方法；对于多实例bean来说，在每次获取bean对象的时候，调用bean的初始化方法。</li>
</ul>
<p>bean对象的销毁方法调用的时机：</p>
<ul>
<li>对于单实例bean来说，在容器关闭的时候，会调用bean的销毁方法；对于多实例bean来说，Spring容器不会管理这个bean，也就不会自动调用这个bean的销毁方法了。可以手动调用多实例bean的销毁方法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrOg0"><img src="https://z3.ax1x.com/2021/07/06/RTrOg0.png" alt="RTrOg0.png"></a></p>
<p><strong>添加getBean()</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrvuT"><img src="https://z3.ax1x.com/2021/07/06/RTrvuT.png" alt="RTrvuT.png"></a></p>
<p><strong>可以看到，多实例的bean在容器关闭的时候是不进行销毁的，也就是说你每次获取时，IOC容器帮你创建出对象交还给你，至于要什么时候销毁这是你自己的事，Spring容器压根就不会再管理这些多实例的bean了</strong></p>
<h2 id="11-使用InitializingBean和DisposableBean来管理bean的生命周期"><a href="#11-使用InitializingBean和DisposableBean来管理bean的生命周期" class="headerlink" title="11. 使用InitializingBean和DisposableBean来管理bean的生命周期"></a>11. 使用InitializingBean和DisposableBean来管理bean的生命周期</h2><h3 id="11-1-InitializingBean接口"><a href="#11-1-InitializingBean接口" class="headerlink" title="11.1 InitializingBean接口"></a>11.1 InitializingBean接口</h3><p>Spring中提供了一个InitializingBean接口，该接口为bean提供了属性初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该接口的类，在bean的属性初始化后都会执行该方法。</p>
<p>源码</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrxDU"><img src="https://z3.ax1x.com/2021/07/06/RTrxDU.png" alt="RTrxDU.png"></a></p>
<p><strong>定位到org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory中</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTrzbF"><img src="https://z3.ax1x.com/2021/07/06/RTrzbF.png" alt="RTrzbF.png"></a></p>
<ul>
<li>Spring为bean提供了两种初始化的方式，实现InitializingBean接口（也就是要实现该接口中的afterPropertiesSet方法），或者在配置文件或@Bean注解中通过init-method来指定，两种方式可以同时使用。</li>
<li>实现InitializingBean接口是直接调用afterPropertiesSet()方法，与通过反射调用init-method指定的方法相比，效率相对来说要高点。但是init-method方式消除了对Spring的依赖。</li>
<li>如果调用afterPropertiesSet方法时出错，那么就不会调用init-method指定的方法了。</li>
</ul>
<p><strong>Spring为bean提供了两种初始化的方式，第一种方式是实现InitializingBean接口（也就是要实现该接口中的afterPropertiesSet方法），第二种方式是在配置文件或@Bean注解中通过init-method来指定，这两种方式可以同时使用，同时使用先调用afterPropertiesSet方法，后执行init-method指定的方法。</strong></p>
<h3 id="11-2-DisposableBean接口"><a href="#11-2-DisposableBean接口" class="headerlink" title="11.2 DisposableBean接口"></a>11.2 DisposableBean接口</h3><p>实现org.springframework.beans.factory.DisposableBean接口的bean在销毁前，Spring将会调用DisposableBean接口的destroy()方法</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTspE4"><img src="https://z3.ax1x.com/2021/07/06/RTspE4.png" alt="RTspE4.png"></a></p>
<p>可以看到，在DisposableBean接口中只定义了一个destroy()方法。</p>
<p>在bean生命周期结束前调用destroy()方法做一些收尾工作，亦可以使用destroy-method。<strong>前者与Spring耦合高，使用类型强转.方法名()，效率高；后者耦合低，使用反射，效率相对来说较低。</strong></p>
<p><strong>DisposableBean接口注意事项</strong></p>
<ul>
<li>多实例bean的生命周期不归Spring容器来管理，这里的DisposableBean接口中的方法是由Spring容器来调用的，所以如果一个多实例bean实现了DisposableBean接口是没有啥意义的，因为相应的方法根本不会被调用，当然了，在XML配置文件中指定了destroy方法，也是没有任何意义的。所以，在多实例bean情况下，Spring是不会自动调用bean的销毁方法的。</li>
</ul>
<h3 id="11-3-单实例案例"><a href="#11-3-单实例案例" class="headerlink" title="11.3 单实例案例"></a>11.3 单实例案例</h3><p>创建一个Cat类实现 InitializingBean, DisposableBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Cat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 猫类 实现 InitializingBean, DisposableBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 22:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat 创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat afterPropertiesSet...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类中添加下列代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一把</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTs9UJ"><img src="https://z3.ax1x.com/2021/07/06/RTs9UJ.png" alt="RTs9UJ.png"></a></p>
<h3 id="11-4-多实例案例"><a href="#11-4-多实例案例" class="headerlink" title="11.4 多实例案例"></a>11.4 多实例案例</h3><p>添加 prototype 注解</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsiCR"><img src="https://z3.ax1x.com/2021/07/06/RTsiCR.png" alt="RTsiCR.png"></a></p>
<h2 id="12-PostConstruct注解和-PreDestroy注解"><a href="#12-PostConstruct注解和-PreDestroy注解" class="headerlink" title="12. @PostConstruct注解和@PreDestroy注解"></a>12. @PostConstruct注解和@PreDestroy注解</h2><h3 id="12-1-PostConstruct注解"><a href="#12-1-PostConstruct注解" class="headerlink" title="12.1 @PostConstruct注解"></a>12.1 @PostConstruct注解</h3><p>@PostConstruct注解被用来修饰一个非静态的void()方法。被@PostConstruct注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。被@PostConstruct注解修饰的方法通常在构造函数之后，init()方法之前执行。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsC59"><img src="https://z3.ax1x.com/2021/07/06/RTsC59.png" alt="RTsC59.png"></a></p>
<p><strong>该注解的方法在整个bean初始化中的执行顺序</strong></p>
<ul>
<li>Constructor（构造方法）→@Autowired（依赖注入）→@PostConstruct（注释的方法）</li>
</ul>
<h3 id="12-2-PreDestroy注解"><a href="#12-2-PreDestroy注解" class="headerlink" title="12.2 @PreDestroy注解"></a>12.2 @PreDestroy注解</h3><p>被@PreDestroy注解修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy注解修饰的方法会在destroy()方法之后，Servlet被彻底卸载之前执行</p>
<p><strong>该注解的方法在整个bean初始化中的执行顺序</strong></p>
<ul>
<li>调用destroy()方法→@PreDestroy→destroy()方法→bean销毁</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsF81"><img src="https://z3.ax1x.com/2021/07/06/RTsF81.png" alt="RTsF81.png"></a></p>
<p><strong>@PostConstruct和@PreDestroy是Java规范JSR-250引入的注解，定义了对象的创建和销毁工作，同一期规范中还有@Resource注解，Spring也支持了这些注解。</strong></p>
<h3 id="12-3-案例"><a href="#12-3-案例" class="headerlink" title="12.3 案例"></a>12.3 案例</h3><p>创建Dog类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Dog</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 狗类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 23:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog constructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对象创建完成并且属性赋值完成之后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog...@PostConstruct...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器销毁（移除）对象之前调用</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog...@PreDestroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTskgx"><img src="https://z3.ax1x.com/2021/07/06/RTskgx.png" alt="RTskgx.png"></a></p>
<p>被@PostConstruct注解修饰的方法是在bean创建完成并且属性赋值完成之后才执行的，而被@PreDestroy注解修饰的方法是在容器销毁bean之前执行的</p>
<h2 id="13-BeanPostProcessor后置处理器"><a href="#13-BeanPostProcessor后置处理器" class="headerlink" title="13. BeanPostProcessor后置处理器"></a>13. BeanPostProcessor后置处理器</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsAv6"><img src="https://z3.ax1x.com/2021/07/06/RTsAv6.png" alt="RTsAv6.png"></a></p>
<p>从源码可以看出，BeanPostProcessor是一个接口，其中有两个方法，即<strong>postProcessBeforeInitialization和postProcessAfterInitialization这两个方法</strong>，这两个方法分别是在Spring容器中的bean初始化前后执行，<strong>所以Spring容器中的每一个bean对象初始化前后，都会执行BeanPostProcessor接口的实现类中的这两个方法。</strong></p>
<p>也就是说，postProcessBeforeInitialization方法<strong>会在bean实例化和属性设置之后，自定义初始化方法之前被调用</strong>，而postProcessAfterInitialization方法<strong>会在自定义初始化方法之后被调用</strong>。当容器中存在多个BeanPostProcessor的实现类时，会按照它们在容器中注册的顺序执行。对于自定义的BeanPostProcessor实现类，还可以让其实现Ordered接口自定义排序。</p>
<p>因此我们可以在每个bean对象初始化前后，加上自己的逻辑。实现方式是自定义一个BeanPostProcessor接口的实现类，例如MyBeanPostProcessor，然后在该类的postProcessBeforeInitialization和postProcessAfterInitialization这俩方法中写上自己的逻辑。</p>
<h3 id="13-1-BeanPostProcessor后置处理器实例"><a href="#13-1-BeanPostProcessor后置处理器实例" class="headerlink" title="13.1 BeanPostProcessor后置处理器实例"></a>13.1 BeanPostProcessor后置处理器实例</h3><p><strong>创建自定义的MyBeanPostProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MyBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 后置处理器，在初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 23:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessBeforeInitialization...&quot;</span> + beanName + <span class="string">&quot;=&gt;&quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postProcessAfterInitialization...&quot;</span> + beanName + <span class="string">&quot;=&gt;&quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Cat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 猫类 实现 InitializingBean, DisposableBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 22:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat 创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat afterPropertiesSet...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Dog</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 狗类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 23:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog constructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对象创建完成并且属性赋值完成之后调用</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog...@PostConstruct...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器销毁（移除）对象之前调用</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog...@PreDestroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Car类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Car</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汽车类 bean的生命周期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/3 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car 创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsVKK"><img src="https://z3.ax1x.com/2021/07/06/RTsVKK.png" alt="RTsVKK.png"></a></p>
<h3 id="13-2-BeanPostProcessor后置处理器作用"><a href="#13-2-BeanPostProcessor后置处理器作用" class="headerlink" title="13.2 BeanPostProcessor后置处理器作用"></a>13.2 BeanPostProcessor后置处理器作用</h3><ul>
<li><p>后置处理器可用于bean对象初始化前后进行逻辑增强。Spring提供了BeanPostProcessor接口的很多实现类，例如AutowiredAnnotationBeanPostProcessor用于@Autowired注解的实现，AnnotationAwareAspectJAutoProxyCreator用于Spring AOP的动态代理等等。</p>
</li>
<li><p>除此之外，我们还可以自定义BeanPostProcessor接口的实现类，在其中写入咱们需要的逻辑。下面我会以AnnotationAwareAspectJAutoProxyCreator为例，简单说明一下后置处理器是怎样工作的。</p>
</li>
<li><p>我们都知道spring AOP的实现原理是动态代理，最终放入容器的是代理类的对象，而不是bean本身的对象，那么Spring是什么时候做到这一步的呢？就是在AnnotationAwareAspectJAutoProxyCreator后置处理器的postProcessAfterInitialization方法中，即bean对象初始化完成之后，后置处理器会判断该bean是否注册了切面，若是，则生成代理对象注入到容器中。这一部分的关键代码是在哪儿呢？<strong>我们定位到AbstractAutoProxyCreator抽象类中的postProcessAfterInitialization方法处便能看到了</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsZDO"><img src="https://z3.ax1x.com/2021/07/06/RTsZDO.png" alt="RTsZDO.png"></a></p>
<h2 id="14-BeanPostProcessor的执行流程"><a href="#14-BeanPostProcessor的执行流程" class="headerlink" title="14. BeanPostProcessor的执行流程"></a>14. BeanPostProcessor的执行流程</h2><h3 id="14-1"><a href="#14-1" class="headerlink" title="14.1"></a>14.1</h3><p><strong>通过@Bean指定init-method和destroy-method</strong></p>
<h3 id="14-2"><a href="#14-2" class="headerlink" title="14.2"></a>14.2</h3><p><strong>通过让bean实现InitializingBean和DisposableBean接口</strong></p>
<h3 id="14-3"><a href="#14-3" class="headerlink" title="14.3"></a>14.3</h3><p><strong>使用JSR-250规范里面定义的@PostConstruct和@PreDestroy这俩注解</strong></p>
<h3 id="14-4"><a href="#14-4" class="headerlink" title="14.4"></a>14.4</h3><p><strong>通过让bean实现BeanPostProcessor接口</strong></p>
<p><strong>Bean的生命周期</strong></p>
<ul>
<li>bean的实例化：调用bean的构造方法，我们可以在bean的无参构造方法中执行相应的逻辑。</li>
<li>bean的初始化：在初始化时，可以通过BeanPostProcessor的postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法进行拦截，执行自定义的逻辑；通过@PostConstruct注解、InitializingBean和init-method来指定bean初始化前后执行的方法，在该方法中咱们可以执行自定义的逻辑。</li>
<li>bean的销毁：可以通过@PreDestroy注解、DisposableBean和destroy-method来指定bean在销毁前执行的方法，在该方法中咱们可以执行自定义的逻辑。</li>
</ul>
<h2 id="15-BeanPostProcessor在Spring底层是如何使用"><a href="#15-BeanPostProcessor在Spring底层是如何使用" class="headerlink" title="15. BeanPostProcessor在Spring底层是如何使用"></a>15. BeanPostProcessor在Spring底层是如何使用</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsAv6"><img src="https://z3.ax1x.com/2021/07/06/RTsAv6.png" alt="RTsAv6.png"></a></p>
<p>在BeanPostProcessor接口中，提供了两个方法：postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法</p>
<ul>
<li>postProcessBeforeInitialization()方法会在bean初始化之前调用</li>
<li>postProcessAfterInitialization()方法会在bean初始化之后调用</li>
</ul>
<p>要想使用ApplicationContextAwareProcessor类向组件中注入IOC容器，我们就不得不提Spring中的另一个接口了，即ApplicationContextAware。如果需要向组件中注入IOC容器，那么可以让组件实现ApplicationContextAware接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-1-ApplicationContextAwareProcessor"><a href="#15-1-ApplicationContextAwareProcessor" class="headerlink" title="15.1 ApplicationContextAwareProcessor"></a>15.1 <strong>ApplicationContextAwareProcessor</strong></h3><p>** <strong>ApplicationContextAwareProcessor类中对于postProcessBeforeInitialization()方法的实现</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsnVe"><img src="https://z3.ax1x.com/2021/07/06/RTsnVe.png" alt="RTsnVe.png"></a></p>
<p>在bean初始化之前，首先对当前bean的类型进行判断，如果当前bean的类型不是EnvironmentAware，不是EmbeddedValueResolverAware，不是ResourceLoaderAware，不是ApplicationEventPublisherAware，不是MessageSourceAware，也不是ApplicationContextAware，那么直接返回bean。<strong>如果是上面类型中的一种类型，那么最终会调用invokeAwareInterfaces()方法，并将bean传递给该方法。</strong></p>
<p><strong>看invokeAwareInterfaces()方法的源码</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/RTsuUH"><img src="https://z3.ax1x.com/2021/07/06/RTsuUH.png" alt="RTsuUH.png"></a></p>
<p>可以看到invokeAwareInterfaces()方法的源码比较简单，就是判断当前bean属于哪种接口类型，然后将bean强转为哪种接口类型的对象，接着调用接口中的方法，将相应的参数传递到接口的方法中。这里，我们在创建Dog类时，实现的是ApplicationContextAware接口，所以，在invokeAwareInterfaces()方法中，会执行如下的逻辑代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">				((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-2-BeanValidationPostProcessor类"><a href="#15-2-BeanValidationPostProcessor类" class="headerlink" title="15.2 BeanValidationPostProcessor类"></a>15.2 BeanValidationPostProcessor类</h3><p>org.springframework.validation.beanvalidation.BeanValidationPostProcessor类主要是<strong>用来为bean进行校验操作的</strong>，当我们创建bean，并为bean赋值后，我们可以通过BeanValidationPostProcessor类为bean进行校验操作</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96nPJ"><img src="https://z3.ax1x.com/2021/07/11/W96nPJ.png" alt="W96nPJ.png"></a></p>
<p>在postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法中的主要逻辑<strong>都是调用doValidate()方法对bean进行校验</strong>，只不过在这两个方法中都会对afterInitialization这个boolean类型的成员变量进行判断，<strong>若afterInitialization的值为false，则在postProcessBeforeInitialization()方法中调用doValidate()方法对bean进行校验；若afterInitialization的值为true，则在postProcessAfterInitialization()方法中调用doValidate()方法对bean进行校验。</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96uG9"><img src="https://z3.ax1x.com/2021/07/11/W96uG9.png" alt="W96uG9.png"></a></p>
<h3 id="15-3-InitDestroyAnnotationBeanPostProcessor类"><a href="#15-3-InitDestroyAnnotationBeanPostProcessor类" class="headerlink" title="15.3 InitDestroyAnnotationBeanPostProcessor类"></a>15.3 InitDestroyAnnotationBeanPostProcessor类</h3><p>org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor类主要用来处理@PostConstruct注解和@PreDestroy注解</p>
<h3 id="15-4-AutowiredAnnotationBeanPostProcessor类"><a href="#15-4-AutowiredAnnotationBeanPostProcessor类" class="headerlink" title="15.4 AutowiredAnnotationBeanPostProcessor类"></a>15.4 AutowiredAnnotationBeanPostProcessor类</h3><p>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor类主要是用于处理标注了@Autowired注解的变量或方法。</p>
<h2 id="16-使用-Value注解为bean的属性赋值"><a href="#16-使用-Value注解为bean的属性赋值" class="headerlink" title="16. 使用@Value注解为bean的属性赋值"></a>16. 使用@Value注解为bean的属性赋值</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96VVU"><img src="https://z3.ax1x.com/2021/07/11/W96VVU.png" alt="W96VVU.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96e54"><img src="https://z3.ax1x.com/2021/07/11/W96e54.png" alt="W96e54.png"></a></p>
<p><strong>Value源码</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96ZaF"><img src="https://z3.ax1x.com/2021/07/11/W96ZaF.png" alt="W96ZaF.png"></a></p>
<ul>
<li>注入普通字符串</li>
</ul>
<p>@Value(“张三”)<br>private String name; // 注入普通字符串</p>
<ul>
<li>注入操作系统属性</li>
</ul>
<p>@Value(“#{systemProperties[‘os.name’]}”)<br>private String systemPropertiesName; // 注入操作系统属性</p>
<ul>
<li>注入SpEL表达式结果</li>
</ul>
<p>@Value(“#{ T(java.lang.Math).random() * 100.0 }”)<br>private double randomNumber; //注入SpEL表达式结果</p>
<ul>
<li>注入其他bean中属性的值</li>
</ul>
<p>@Value(“#{person.name}”)<br>private String username; // 注入其他bean中属性的值，即注入person对象的name属性中的值</p>
<ul>
<li>注入文件资源</li>
</ul>
<p>@Value(“classpath:/config.properties”)<br>private Resource resourceFile; // 注入文件资源</p>
<ul>
<li>注入URL资源</li>
</ul>
<p>@Value(“<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>)<br>private Resource url; // 注入URL资源</p>
<ul>
<li><code>#&#123;···&#125;</code>：用于执行SpEl表达式，并将内容赋值给属性</li>
<li><code>$&#123;···&#125;</code>：主要用于加载外部属性文件中的值</li>
<li><code>$&#123;···&#125;</code>和<code>#&#123;···&#125;</code>可以混合使用，但是必须<code>#&#123;&#125;</code>在外面，<code>$&#123;&#125;</code>在里面</li>
</ul>
<h2 id="17-使用-PropertySource加载配置文件"><a href="#17-使用-PropertySource加载配置文件" class="headerlink" title="17. 使用@PropertySource加载配置文件"></a>17. 使用@PropertySource加载配置文件</h2><p>@PropertySource注解是Spring 3.1开始引入的配置类注解。通过@PropertySource注解可以将properties配置文件中的key/value存储到Spring的Environment中，Environment接口提供了方法去读取配置文件中的值，参数是properties配置文件中定义的key值</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96K2R"><img src="https://z3.ax1x.com/2021/07/11/W96K2R.png" alt="W96K2R.png"></a></p>
<p><strong>@PropertySources注解的源码比较简单，只有一个PropertySource[]数组类型的value属性</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96Mx1"><img src="https://z3.ax1x.com/2021/07/11/W96Mx1.png" alt="W96Mx1.png"></a></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySources(value=&#123;</span></span><br><span class="line"><span class="meta">    @PropertySource(value=&#123;&quot;classpath:/person.properties&quot;&#125;),</span></span><br><span class="line"><span class="meta">    @PropertySource(value=&#123;&quot;classpath:/car.properties&quot;&#125;),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W961r6"><img src="https://z3.ax1x.com/2021/07/11/W961r6.png" alt="W961r6.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96GVO"><img src="https://z3.ax1x.com/2021/07/11/W96GVO.png" alt="W96GVO.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W963qK"><img src="https://z3.ax1x.com/2021/07/11/W963qK.png" alt="W963qK.png"></a></p>
<p>测试一把</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96lKx"><img src="https://z3.ax1x.com/2021/07/11/W96lKx.png" alt="W96lKx.png"></a></p>
<h3 id="17-1-使用Environment获取值"><a href="#17-1-使用Environment获取值" class="headerlink" title="17.1 使用Environment获取值"></a>17.1 使用Environment获取值</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96YIe"><img src="https://z3.ax1x.com/2021/07/11/W96YIe.png" alt="W96YIe.png"></a></p>
<h2 id="18-使用-Autowired、-Qualifier、-Primary这三大注解自动装配组件"><a href="#18-使用-Autowired、-Qualifier、-Primary这三大注解自动装配组件" class="headerlink" title="18. 使用@Autowired、@Qualifier、@Primary这三大注解自动装配组件"></a>18. 使用@Autowired、@Qualifier、@Primary这三大注解自动装配组件</h2><h3 id="18-1-Autowired注解"><a href="#18-1-Autowired注解" class="headerlink" title="18.1 @Autowired注解"></a>18.1 @Autowired注解</h3><p>@Autowired注解可以对类成员变量、方法和构造函数进行标注，完成自动装配的工作。@Autowired注解可以放在类、接口以及方法上。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96JaD"><img src="https://z3.ax1x.com/2021/07/11/W96JaD.png" alt="W96JaD.png"></a></p>
<p><strong>对@Autowired注解说明一下：</strong></p>
<p>@Autowired注解默认是优先按照类型去容器中找对应的组件，相当于是调用了如下这个方法：</p>
<ul>
<li>applicationContext.getBean(类名.class);<br>若找到则就赋值。</li>
</ul>
<p>如果找到多个相同类型的组件，那么是将属性名称作为组件的id，到IOC容器中进行查找，这时就相当于是调用了如下这个方法：</p>
<ul>
<li>applicationContext.getBean(“组件的id”);</li>
</ul>
<h3 id="18-2-Qualifier注解"><a href="#18-2-Qualifier注解" class="headerlink" title="18.2 @Qualifier注解"></a>18.2 @Qualifier注解</h3><p>@Autowired是<strong>根据类型进行自动装配的</strong>，如果需要按名称进行装配，那么就需要配合@Qualifier注解来使用了</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96NPH"><img src="https://z3.ax1x.com/2021/07/11/W96NPH.png" alt="W96NPH.png"></a></p>
<h3 id="18-3-Primary注解"><a href="#18-3-Primary注解" class="headerlink" title="18.3 @Primary注解"></a>18.3 @Primary注解</h3><p>在Spring中使用注解时，常常会使用到@Autowired这个注解，它默认是根据类型Type来自动注入的。但有些特殊情况，对同一个接口而言，可能会有几种不同的实现类，而在默认只会采取其中一种实现的情况下，就可以<strong>使用@Primary注解来标注优先使用哪一个实现类。</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96UGd"><img src="https://z3.ax1x.com/2021/07/11/W96UGd.png" alt="W96UGd.png"></a></p>
<p><strong>自动装配</strong></p>
<p>Spring组件的自动装配就是<strong>Spring利用依赖注入，也就是我们通常所说的DI，完成对IOC容器中各个组件的依赖关系赋值。</strong></p>
<h2 id="19-使用-Resource注解和-Inject注解"><a href="#19-使用-Resource注解和-Inject注解" class="headerlink" title="19. 使用@Resource注解和@Inject注解"></a>19. 使用@Resource注解和@Inject注解</h2><h3 id="19-1-Resource注解"><a href="#19-1-Resource注解" class="headerlink" title="19.1 @Resource注解"></a>19.1 @Resource注解</h3><p>@Resource注解是Java规范里面的，也可以说它是JSR250规范里面定义的一个注解。该注解默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，那么默认取字段名将其作为组件的名称在IOC容器中进行查找，如果注解写在setter方法上，那么默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的一点是，如果name属性一旦指定，那么就只会按照名称进行装配</p>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">lookup</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> java.lang.Object.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The two possible authentication types for a resource.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AuthenticationType</span> </span>&#123;</span><br><span class="line">            CONTAINER,</span><br><span class="line">            APPLICATION</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function">AuthenticationType <span class="title">authenticationType</span><span class="params">()</span> <span class="keyword">default</span> AuthenticationType.CONTAINER</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shareable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">mappedName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-2-Inject注解"><a href="#19-2-Inject注解" class="headerlink" title="19.2 @Inject注解"></a>19.2 @Inject注解</h3><p>@Inject注解也是Java规范里面的，也可以说它是JSR330规范里面定义的一个注解。该注解默认是根据参数名去寻找bean注入，支持Spring的@Primary注解优先注入，@Inject注解还可以增加@Named注解指定要注入的bean</p>
<p>使用前先导入相关依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>@Resource注解和@Autowired注解的功能是一样的，都能实现自动装配，只不过@Resource注解默认是按照组件名称（即属性的名称）进行装配的。虽然@Resource注解具备自动装配这一功能，但是它是不支持@Primary注解优先注入的功能的，而且也不能像@Autowired注解一样能添加required=false属性</p>
</li>
<li><p>@Inject注解和@Autowired注解的功能是一样的，都能实现自动装配，而且它俩都支持@Primary注解优先注入的功能。只不过，@Inject注解不能像@Autowired注解一样能添加<code>required=false</code>属性，因为它里面没啥属性</p>
</li>
</ul>
<p><strong>@Resource和@Inject与@Autowired注解的区别</strong><br><strong>不同点</strong></p>
<ul>
<li>@Autowired是Spring中的专有注解，而@Resource是Java中JSR250规范里面定义的一个注解，@Inject是Java中JSR330规范里面定义的一个注解</li>
<li>@Autowired支持参数required=false，而@Resource和@Inject都不支持</li>
<li>@Autowired和@Inject支持@Primary注解优先注入，而@Resource不支持</li>
<li>@Autowired通过@Qualifier指定注入特定bean，@Resource可以通过参数name指定注入bean，而@Inject需要通过@Named注解指定注入bean</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>三种注解都可以实现bean的自动装配。</li>
</ul>
<p><strong>如果方法只有一个IOC容器中的对象作为参数，当@Autowired注解标注在这个方法的参数上时，我们可以将@Autowired注解省略掉。也就说@Bean注解标注的方法在创建对象的时候，方法参数的值是从IOC容器中获取的，此外，标注在这个方法的参数上的@Autowired注解可以省略。</strong></p>
<h2 id="20-使用-Profile注解实现开发、测试和生产环境的配置和切换"><a href="#20-使用-Profile注解实现开发、测试和生产环境的配置和切换" class="headerlink" title="20. 使用@Profile注解实现开发、测试和生产环境的配置和切换"></a>20. 使用@Profile注解实现开发、测试和生产环境的配置和切换</h2><h3 id="20-1-Profile注解概述"><a href="#20-1-Profile注解概述" class="headerlink" title="20.1 @Profile注解概述"></a>20.1 @Profile注解概述</h3><p>在容器中如果存在同一类型的多个组件，那么可以使用@Profile注解标识要获取的是哪一个bean。也可以说@Profile注解是Spring为我们提供的可以根据当前环境，动态地激活和切换一系列组件的功能。这个功能在不同的环境使用不同的变量的情景下特别有用，例如，开发环境、测试环境、生产环境使用不同的数据源，在不改变代码的情况下，可以使用这个注解来动态地切换要连接的数据库</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96aRA"><img src="https://z3.ax1x.com/2021/07/11/W96aRA.png" alt="W96aRA.png"></a></p>
<h1 id="二，AOP"><a href="#二，AOP" class="headerlink" title="二，AOP"></a>二，AOP</h1><h2 id="1-搭建一个AOP测试环境"><a href="#1-搭建一个AOP测试环境" class="headerlink" title="1. 搭建一个AOP测试环境"></a>1. 搭建一个AOP测试环境</h2><p>AOP概念</p>
<p>AOP（Aspect Orient Programming），直译过来就是面向切面编程。AOP是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96sZ8"><img src="https://z3.ax1x.com/2021/07/11/W96sZ8.png" alt="W96sZ8.png"></a></p>
<p><strong>1.先导入相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.定义目标类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MathCalculator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 计算器类 测试aop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 12:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhuang.aop.LogAspects;</span><br><span class="line"><span class="keyword">import</span> com.zhuang.aop.MathCalculator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> MainConfigOfAOP</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用一句话描述类的作用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 12:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     AOP：面向切面编程，其底层就是动态代理</span></span><br><span class="line"><span class="comment">      指在程序运行期间动态地将某段代码切入到指定方法指定位置进行运行的编程方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 将业务逻辑类（目标方法所在类）加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathCalculator <span class="title">calculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将切面类加入到容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.定义切面类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> LogAspects</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 12:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//告诉Spring是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.zhuang.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @Before：在目标方法（即div方法）运行之前切入，public int com.meimeixia.aop.MathCalculator.div(int, int)这一串就是切入点表达式，指定在哪个方法切入</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法运行......@Before，参数列表是：&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）结束时被调用</span></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法结束......@After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）正常返回了，有返回值，被调用</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法正常返回......@AfterReturning，运行结果是：&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）出现异常，被调用</span></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除法出现异常......异常信息：&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96dxI"><img src="https://z3.ax1x.com/2021/07/11/W96dxI.png" alt="W96dxI.png"></a></p>
<p><strong>AOP中的通知方法及其对应的注解与含义如下：</strong></p>
<ul>
<li>前置通知（对应的注解是@Before）：在目标方法运行之前运行</li>
<li>后置通知（对应的注解是@After）：在目标方法运行结束之后运行，无论目标方法是正常结束还是异常结束都会执行</li>
<li>返回通知（对应的注解是@AfterReturning）：在目标方法正常返回之后运行</li>
<li>异常通知（对应的注解是@AfterThrowing）：在目标方法运行出现异常之后运行</li>
<li>环绕通知（对应的注解是@Around）：动态代理，我们可以直接手动推进目标方法运行（joinPoint.procced()）</li>
</ul>
<p><font color="red">必须告诉Spring哪个类是切面类只需要给切面类上加上一个@Aspect注解即可</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> LogAspects</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 12:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//告诉Spring是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 抽取公共的切面</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public int com.zhuang.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// @Before：在目标方法（即div方法）运行之前切入，public int com.meimeixia.aop.MathCalculator.div(int, int)这一串就是切入点表达式，指定在哪个方法切入</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;运行......@Before，参数列表是：&#123;&quot;</span>+ Arrays.asList(args) +<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）结束时被调用</span></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;除法结束......@After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）正常返回了，有返回值，被调用</span></span><br><span class="line"> <span class="comment">//   @AfterReturning(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;pointCut()&quot;, returning=&quot;result&quot;)</span> <span class="comment">// returning来指定我们这个方法的参数谁来封装返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;除法正常返回......@AfterReturning，运行结果是：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标方法（即div方法）出现异常，被调用</span></span><br><span class="line"> <span class="comment">//   @AfterThrowing(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointCut()&quot;,throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;除法出现异常......异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**需要在切面类中打印出参数列表和运行结果 按照图片修改代码 **</p>
<p><font color="red"><strong>需要注意的是，JoinPoint参数一定要放在参数列表的第一位，否则Spring是无法识别的</strong></font></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96Dqf"><img src="https://z3.ax1x.com/2021/07/11/W96Dqf.png" alt="W96Dqf.png"></a></p>
<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W960Mt"><img src="https://z3.ax1x.com/2021/07/11/W960Mt.png" alt="W960Mt.png"></a></p>
<p>修改测试类中的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tes04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAOP.class);</span><br><span class="line">        MathCalculator bean = applicationContext.getBean(MathCalculator.class);</span><br><span class="line">        bean.div(<span class="number">6</span>,<span class="number">0</span>);<span class="comment">//搞个异常出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96BsP"><img src="https://z3.ax1x.com/2021/07/11/W96BsP.png" alt="W96BsP.png"></a></p>
<p><strong>小结AOP步骤</strong></p>
<ul>
<li>将切面类和业务逻辑组件（目标方法所在类）都加入到容器中，并且要告诉Spring哪个类是切面类（标注了@Aspect注解的那个类）。</li>
<li>在切面类上的每个通知方法上标注通知注解，告诉Spring何时何地运行，当然最主要的是要写好切入点表达式，这个切入点表达式可以参照官方文档来写。</li>
<li>开启基于注解的AOP模式，即加上@EnableAspectJAutoProxy注解，这是最关键的一点。</li>
</ul>
<h2 id="2-EnableAspectJAutoProxy注解"><a href="#2-EnableAspectJAutoProxy注解" class="headerlink" title="2. @EnableAspectJAutoProxy注解"></a>2. @EnableAspectJAutoProxy注解</h2><p>在配置类上添加@EnableAspectJAutoProxy注解，便能够开启注解版的AOP功能。也就是说，如果要使注解版的AOP功能起作用的话，那么就得需要在配置类上添加@EnableAspectJAutoProxy注解</p>
<p><strong>进入@EnableAspectJAutoProxy注解</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96ydS"><img src="https://z3.ax1x.com/2021/07/11/W96ydS.png" alt="W96ydS.png"></a></p>
<p><strong>从源码中可以看出，@EnableAspectJAutoProxy注解使用@Import注解给容器中引入了AspectJAutoProxyRegister组件</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96giQ"><img src="https://z3.ax1x.com/2021/07/11/W96giQ.png" alt="W96giQ.png"></a></p>
<p><strong>看到AspectJAutoProxyRegistrar类实现了ImportBeanDefinitionRegistrar接口</strong></p>
<p><strong>可以通过ImportBeanDefinitionRegistrar接口实现将自定义的组件添加到IOC容器中</strong></p>
<p>得出结论</p>
<p><strong><font color="red">@EnableAspectJAutoProxy注解使用AspectJAutoProxyRegistrar对象自定义组件，并将相应的组件添加到了IOC容器中。</font></strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W966Ig"><img src="https://z3.ax1x.com/2021/07/11/W966Ig.png" alt="W966Ig.png"></a></p>
<p>程序已经暂停在断点位置</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W962Gj"><img src="https://z3.ax1x.com/2021/07/11/W962Gj.png" alt="W962Gj.png"></a></p>
<p>在AspectJAutoProxyRegistrar类的registerBeanDefinitions()方法里面，首先调用了AopConfigUtils类的<strong>registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法来注册registry</strong>，字面含义就是：如果需要的话，那么就注册一个AspectJAnnotationAutoProxyCreator组件。</p>
<p>进入到AopConfigUtils类的**registerAspectJAnnotationAutoProxyCreatorIfNecessary()**方法中</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96RRs"><img src="https://z3.ax1x.com/2021/07/11/W96RRs.png" alt="W96RRs.png"></a></p>
<p>在AopConfigUtils类的registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法中，<strong>直接调用了重载的registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96Wzn"><img src="https://z3.ax1x.com/2021/07/11/W96Wzn.png" alt="W96Wzn.png"></a></p>
<p>可以看到在重载的registerAspectJAnnotationAutoProxyCreatorIfNecessary()方法中直接<strong>调用了registerOrEscalateApcAsRequired()方法，并且在registerOrEscalateApcAsRequired()方法中，传入了AnnotationAwareAspectJAutoProxyCreator.class对象</strong><br><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96hMq"><img src="https://z3.ax1x.com/2021/07/11/W96hMq.png" alt="W96hMq.png"></a></p>
<p>在registerOrEscalateApcAsRequired()方法中，接收到的Class对象的类型为org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator。</p>
<p>除此之外，我们还可以看到，在registerOrEscalateApcAsRequired()方法中会做一个判断，<strong>即首先判断registry（也就是IOC容器）是否包含名称为org.springframework.aop.config.internalAutoProxyCreator的bean</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W967oF"><img src="https://z3.ax1x.com/2021/07/11/W967oF.png" alt="W967oF.png"></a></p>
<p>如果registry中包含名称为org.springframework.aop.config.internalAutoProxyCreator的bean，那么就进行相应的处理。从Spring的源码来看，就是将名称为org.springframework.aop.config.internalAutoProxyCreator的bean从容器中取出，并且判断cls对象的name值和apcDefinition的beanClassName值是否相等，若不相等，则获取apcDefinition和cls它俩的优先级，如果apcDefinition的优先级小于cls的优先级，那么将apcDefinition的beanClassName设置为cls的name值。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W964s0"><img src="https://z3.ax1x.com/2021/07/11/W964s0.png" alt="W964s0.png"></a></p>
<p>这里会使用RootBeanDefinition来创建一个bean的定义信息（即beanDefinition），<strong>并且将org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator的Class对象作为参数传递进来。</strong></p>
<p>最终在AopConfigUtils类的registerOrEscalateApcAsRequired()方法中，<strong>会通过registry调用registerBeanDefinition()方法注册组件</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W965LV"><img src="https://z3.ax1x.com/2021/07/11/W965LV.png" alt="W965LV.png"></a></p>
<p><strong>注册的组件的类型是</strong>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator，组件的名字是org.springframework.aop.config.internalAutoProxyCreator。</p>
<p>查看AspectJAutoProxyRegistrar类中的<strong>registerBeanDefinitions()方法的源码</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96TdU"><img src="https://z3.ax1x.com/2021/07/11/W96TdU.png" alt="W96TdU.png"></a></p>
<p>通过AnnotationConfigUtils类的<strong>attributesFor()方法</strong>来获取@EnableAspectJAutoProxy注解的信息。接着，就是<strong>判断proxyTargetClass属性的值是否为true</strong>，若为true则调用AopConfigUtils类的<strong>forceAutoProxyCreatorToUseClassProxying()方法</strong>；<strong>继续判断exposeProxy属性的值是否为true</strong>，若为true则调用AopConfigUtils类的<strong>forceAutoProxyCreatorToExposeProxy()方法，</strong>其实就是暴露一些什么代理的这些bean.</p>
<p><strong>综上，向Spring的配置类上添加@EnableAspectJAutoProxy注解之后，会向IOC容器中注册AnnotationAwareAspectJAutoProxyCreator，翻译过来就叫注解装配模式的AspectJ切面自动代理创建器。</strong></p>
<p><strong>AnnotationAwareAspectJAutoProxyCreator类的结构图</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96oZT"><img src="https://z3.ax1x.com/2021/07/11/W96oZT.png" alt="W96oZT.png"></a></p>
<p><strong>查看继承关系可以发现，此类实现了Aware与BeanPostProcessor接口，这两个接口都和Spring bean的初始化有关，由此可以推测此类的主要处理方法都来自于这两个接口中的实现方法。</strong></p>
<blockquote>
<p>AnnotationAwareAspectJAutoProxyCreator<br>    -&gt;AspectJAwareAdvisorAutoProxyCreator（父类）<br>        -&gt;AbstractAdvisorAutoProxyCreator（父类）<br>            -&gt;AbstractAutoProxyCreator（父类）<br>                implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware（两个接口）</p>
</blockquote>
<h2 id="3-为AnnotationAwareAspectJAutoProxyCreator组件里面和后置处理器以及Aware接口有关的方法打上断点"><a href="#3-为AnnotationAwareAspectJAutoProxyCreator组件里面和后置处理器以及Aware接口有关的方法打上断点" class="headerlink" title="3.为AnnotationAwareAspectJAutoProxyCreator组件里面和后置处理器以及Aware接口有关的方法打上断点"></a>3.为AnnotationAwareAspectJAutoProxyCreator组件里面和后置处理器以及Aware接口有关的方法打上断点</h2><p>通过以上继承关系，我们也知道了，它最终会实现两个接口，分别是：</p>
<ul>
<li>BeanPostProcessor：后置处理器，即在bean初始化完成前后做些事情</li>
<li>BeanFactoryAware：自动注入BeanFactory</li>
</ul>
<p>也就是说，AnnotationAwareAspectJAutoProxyCreator不仅是一个后置处理器，还是一个BeanFactoryAware接口的实现类。那么我们就来分析它作为后置处理器，到底做了哪些工作，以及它作为BeanFactoryAware接口的实现类，又做了哪些工作</p>
<p>我们找到该抽象类，并在里面查找与Aware接口以及BeanPostProcessor接口有关的方法，结果都是可以找到的。<strong>该抽象类中的setBeanFactory()方法就是与Aware接口有关的方法，因此我们将断点打在该方法上</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96bi4"><img src="https://z3.ax1x.com/2021/07/11/W96bi4.png" alt="W96bi4.png"></a> </p>
<p>找到该抽象类中与BeanPostProcessor接口有关的方法，即只要发现有与后置处理器相关的逻辑，就给所有与后置处理器有关的逻辑都打上断点。打的断点有两处，<strong>一处是在postProcessBeforeInstantiation()方法上</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96qJJ"><img src="https://z3.ax1x.com/2021/07/11/W96qJJ.png" alt="W96qJJ.png"></a></p>
<p><strong>一处是在postProcessAfterInitialization()方法上</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96LW9"><img src="https://z3.ax1x.com/2021/07/11/W96LW9.png" alt="W96LW9.png"></a></p>
<p>再来看它的子类（即AbstractAdvisorAutoProxyCreator），从顶层开始一点一点往上分析。</p>
<p><strong>在该抽象类中，我们只能找到一个与Aware接口有关的方法，即setBeanFactory()方法，虽然父类有setBeanFactory()方法，但是在这个子类里面已经把它重写了，因此最终调用的应该就是它</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96OzR"><img src="https://z3.ax1x.com/2021/07/11/W96OzR.png" alt="W96OzR.png"></a></p>
<p>在重写的时候，在setBeanFactory()方法里面会调用一个initBeanFactory()方法。<strong>除此之外，该抽象类中就没有跟后置处理器有关的方法了。</strong></p>
<p>接下来，来看AspectJAwareAdvisorAutoProxyCreator这个类了，但由于这个类里面没有跟BeanPostProcessor接口有关的方法，所以我们就不必看这个类了，略过。</p>
<p>接下来，我们就要来看最顶层的类了，即AnnotationAwareAspectJAutoProxyCreator。查看该类时，发现有这样一个initBeanFactory()方法，我们在该方法上打上一个断点</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96vsx"><img src="https://z3.ax1x.com/2021/07/11/W96vsx.png" alt="W96vsx.png"></a></p>
<p><strong>为什么在该类里面会有这个方法呢？因为我们在它的父类里面会调用setBeanFactory()方法，而在该方法里面又会调用initBeanFactory()方法，虽然父类里面有写，但是又被它的子类给重写了，所以说相当于父类中的setBeanFactory()方法还是得调用它。</strong></p>
<p><strong>为MainConfigOfAOP配置类中的如下两个方法打上断点</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W96xL6"><img src="https://z3.ax1x.com/2021/07/11/W96xL6.png" alt="W96xL6.png"></a></p>
<h2 id="4-分析创建和注册AnnotationAwareAspectJAutoProxyCreator的过程"><a href="#4-分析创建和注册AnnotationAwareAspectJAutoProxyCreator的过程" class="headerlink" title="4. 分析创建和注册AnnotationAwareAspectJAutoProxyCreator的过程"></a>4. 分析创建和注册AnnotationAwareAspectJAutoProxyCreator的过程</h2><p><strong>bebug一把</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9cSeK"><img src="https://z3.ax1x.com/2021/07/11/W9cSeK.png" alt="W9cSeK.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9cpdO"><img src="https://z3.ax1x.com/2021/07/11/W9cpdO.png" alt="W9cpdO.png"></a></p>
<p>传入主配置类来创建IOC容器使用的是AnnotationConfigApplicationContext类的有参构造器，它具体分为下面三步：</p>
<ul>
<li>首先使用无参构造器创建对象</li>
<li>再来把主配置类注册进来</li>
<li>最后调用refresh()方法刷新容器，刷新容器就是要把容器中的所有bean都创建出来，也就是说这就像初始化容器一样</li>
</ul>
<p>重要的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register bean processors that intercept bean creation.  注册bean的后置处理器</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9c9oD"><img src="https://z3.ax1x.com/2021/07/11/W9c9oD.png" alt="W9c9oD.png"></a></p>
<p><strong>定位到PostProcessorRegistrationDelegate类的registerBeanPostProcessors()方法中</strong></p>
<p><strong>怎么注册bean的后置处理器的。</strong></p>
<p>先按照类型拿到IOC容器中所有需要创建的后置处理器，即先获取IOC容器中已经定义了的需要创建对象的所有BeanPostProcessor。这可以从如下这行代码中得知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>为什么IOC容器中会有一些已定义的BeanPostProcessor呢？这是因为在前面创建IOC容器时，需要先传入配置类，而我们在解析配置类的时候，由于这个配置类里面有一个@EnableAspectJAutoProxy注解，对于该注解，它会为我们容器中注册一个AnnotationAwareAspectJAutoProxyCreator（后置处理器），这还仅仅是这个@EnableAspectJAutoProxy注解做的事，除此之外，容器中还有一些默认的后置处理器的定义。</p>
<p>程序运行到这，容器中已经有一些我们将要用的后置处理器了，只不过现在还没创建对象，都只是一些定义，也就是说容器中有哪些后置处理器。</p>
<p>继续往下看这个registerBeanPostProcessors()方法，可以看到它里面还有其他的逻辑，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure>

<p>说的是给beanFactory中额外还加了一些其他的BeanPostProcessor，也就是说给容器中加别的BeanPostProcessor。</p>
<p>继续往下看这个registerBeanPostProcessors()方法，发现它里面还有这样的注释，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br></pre></td></tr></table></figure>


<p>说的是分离这些BeanPostProcessor，看哪些是实现了PriorityOrdered接口的，哪些又是实现了Ordered接口的，包括哪些是原生的没有实现什么接口的。所以，在这儿，对这些BeanPostProcessor还做了一些处理，所做的处理看以下代码便一目了然。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        priorityOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">        orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IOC容器中的那些BeanPostProcessor是有优先级排序的</strong></p>
<p><img src="https://pic.imgdb.cn/item/60ea9e635132923bf8de6032.png"></p>
<p><strong>IOC容器中的那些BeanPostProcessor可以实现PriorityOrdered以及Ordered这些接口来定义它们工作的优先级，即谁先前谁先后</strong></p>
<p>在这儿将这些BeanPostProcessor做了一下划分，如果BeanPostProcessor实现了PriorityOrdered接口，那么就将其保存在名为priorityOrderedPostProcessors的List集合中，并且要是该BeanPostProcessor还是MergedBeanDefinitionPostProcessor这种类型的，则还得将其保存在名为internalPostProcessors的List集合中</p>
<p><strong>继续往下看这个registerBeanPostProcessors()方法，主要是看其中的注释，不难发现有以下三步：</strong></p>
<ul>
<li><p>优先注册实现了PriorityOrdered接口的BeanPostProcessor</p>
</li>
<li><p>再给容器中注册实现了Ordered接口的BeanPostProcessor</p>
</li>
<li><p>最后再注册没实现优先级接口的BeanPostProcessor</p>
<p>那么，所谓的注册BeanPostProcessor又是什么呢？我们还是来到程序停留的地方，为啥子程序会停留在这儿呢？因为咱们现在即将要创建的名称为internalAutoProxyCreator的组件（其实它就是我们之前经常讲的AnnotationAwareAspectJAutoProxyCreator）实现了Ordered接口，这只要查看AnnotationAwareAspectJAutoProxyCreator类的源码便知，一级一级地往上查</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9cPFe"><img src="https://z3.ax1x.com/2021/07/11/W9cPFe.png" alt="W9cPFe.png"></a></p>
<p><strong>先拿到要注册的BeanPostProcessor的名字，然后再从beanFactory中来获取。</strong></p>
<p><img src="https://z3.ax1x.com/2021/07/11/W9ciJH.png" alt="W9ciJH.png"></p>
<p><strong>接下来，我们就要获取相应名字的BeanPostProcessor了，怎么获取呢？继续跟进方法调用栈，如下图所示，可以看到现在是定位到了AbstractBeanFactory抽象类的getBean()方法中。</strong></p>
<p><img src="https://z3.ax1x.com/2021/07/11/W9cFWd.png" alt="W9cFWd.png"></p>
<p><strong>定位到了AbstractBeanFactory抽象类的doGetBean()方法中</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaaaaf5132923bf8326705.png"></p>
<p><strong>定位到了DefaultSingletonBeanRegistry类的getSingleton()方法中</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaaaaf5132923bf832671b.png"></p>
<p><img src="https://pic.imgdb.cn/item/60eaaaaf5132923bf8326735.png"></p>
<p><strong>现在又定位到了AbstractBeanFactory抽象类的doGetBean()方法中</strong></p>
<p>可以发现，现在就是来创建bean的，也就是说如果获取不到那么就创建bean。咱们现在就是需要注册BeanPostProcessor，说白了，实际上就是创建BeanPostProcessor对象，然后保存在容器中。</p>
<p>那么接下来，我们就来看看是如何创建出名称为internalAutoProxyCreator的BeanPostProcessor的，它的类型其实就是我们之前经常说的AnnotationAwareAspectJAutoProxyCreator。我们就以它为例，来看看它这个对象是怎么创建出来的。</p>
<p><strong>我们继续跟进方法调用栈，如下图所示，可以看到现在是定位到了AbstractAutowireCapableBeanFactory抽象类的createBean()方法中。</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaaa655132923bf830bc8a.png"></p>
<p>程序停留在这儿，就是在初始化bean实例，说明bean实例已经创建好了,会看到一个createBeanInstance()方法，说的就是bean实例的创建。创建的是哪个bean实例呢？就是名称为internalAutoProxyCreator的实例，该实例的类型就是我们之前经常说的AnnotationAwareAspectJAutoProxyCreator，即创建这个类型的实例。创建好了之后，就在程序停留的地方进行初始化。</p>
<p>整个的过程</p>
<ul>
<li>首先创建bean的实例</li>
<li>然后给bean的各种属性赋值（即调用populateBean()方法）</li>
<li>接着初始化bean（即调用initializeBean()方法），这个初始化bean其实特别地重要，因为我们这个后置处理器就是在bean初始化的前后进行工作的。</li>
<li>接下来，我们就来看看这个bean的实例是如何初始化的。继续跟进方法调用栈，如下图所示，可以看到现在是定位到了AbstractAutowireCapableBeanFactory抽象类的initializeBean()方法中。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9ofbj"><img src="https://z3.ax1x.com/2021/07/11/W9ofbj.png" alt="W9ofbj.png"></a></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9635132923bf82a34f0.png"></p>
<p><strong>分析一下初始化bean的流程</strong></p>
<p>首先进入invokeAwareMethods()这个方法</p>
<p><img src="https://pic.imgdb.cn/item/60eaa97e5132923bf82aeb62.png"></p>
<p>这个方法是来判断我们这个bean对象是不是Aware接口的，如果是，并且它还是BeanNameAware、BeanClassLoaderAware以及BeanFactoryAware这几个Aware接口中的其中一个，那么<strong>就调用相关的Aware接口方法，即处理Aware接口的方法回调。</strong></p>
<p>现在当前的这个bean叫internalAutoProxyCreator，并且这个bean对象已经被创建出来了，创建出来的这个bean对象之前我们也分析过，它是有实现BeanFactoryAware接口的，故而会调用相关的Aware接口方法，这也是程序为什么会停留在invokeAwareMethods()这个方法的原因</p>
<p>往下翻阅initializeBean()方法，会发现有一个叫applyBeanPostProcessorsBeforeInitialization的方法</p>
<p>该方法的意思其实就是应用后置处理器的postProcessBeforeInitialization()方法</p>
<p>可以看到，它是拿到所有的后置处理器，然后再调用后置处理器的postProcessBeforeInitialization()方法，也就是说bean初始化之前后置处理器的调用在这儿。</p>
<p>拿到所有的后置处理器，然后再调用后置处理器的postProcessAfterInitialization()方法。</p>
<p><img src="https://pic.imgdb.cn/item/60eaa9905132923bf82b5fec.png"></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9905132923bf82b6002.png"></p>
<p><strong>定位到了AbstractAdvisorAutoProxyCreator抽象类的setBeanFactory()方法中</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9905132923bf82b6019.png"></p>
<p><strong>直接进去AnnotationAwareAspectJAutoProxyCreator这个类的initBeanFactory()方法中了，即调到了我们要给容器中创建的AspectJ自动代理创建器的initBeanFactory()方法中</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9fb5132923bf82e5378.png"></p>
<p>initBeanFactory()方法创建了两个东西，一个叫ReflectiveAspectJAdvisorFactory，还有一个叫BeanFactoryAspectJAdvisorsBuilderAdapter，它相当于把之前创建的aspectJAdvisorFactory以及beanFactory重新包装了一下</p>
<p><img src="https://pic.imgdb.cn/item/60eaa9905132923bf82b604b.png"></p>
<p><strong>后置处理器创建完以后会添加到我们已创建的那个bean集合里面</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9905132923bf82b605e.png"></p>
<p><strong>调用sortPostProcessors()方法按照优先级给这些后置处理器们排一个序，程序再往下运行，就会调用到registerBeanPostProcessors()方法</strong></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9fb5132923bf82e5332.png"></p>
<p>注册流程： <strong>拿到所有的BeanPostProcessor，然后调用beanFactory的addBeanPostProcessor()方法将BeanPostProcessor注册到BeanFactory中</strong></p>
<h2 id="5-AnnotationAwareAspectJAutoProxyCreator作为后置处理器"><a href="#5-AnnotationAwareAspectJAutoProxyCreator作为后置处理器" class="headerlink" title="5. AnnotationAwareAspectJAutoProxyCreator作为后置处理器"></a>5. AnnotationAwareAspectJAutoProxyCreator作为后置处理器</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111413608">https://liayun.blog.csdn.net/article/details/111413608</a></p>
<h2 id="6-目标方法的拦截逻辑"><a href="#6-目标方法的拦截逻辑" class="headerlink" title="6. 目标方法的拦截逻辑"></a>6. 目标方法的拦截逻辑</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111516728">https://liayun.blog.csdn.net/article/details/111516728</a></p>
<h2 id="7-拦截器链的执行过程"><a href="#7-拦截器链的执行过程" class="headerlink" title="7. 拦截器链的执行过程"></a>7. 拦截器链的执行过程</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111603408">https://liayun.blog.csdn.net/article/details/111603408</a></p>
<h2 id="8-AOP总结"><a href="#8-AOP总结" class="headerlink" title="8. AOP总结"></a>8. AOP总结</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://liayun.blog.csdn.net/article/details/111677048">https://liayun.blog.csdn.net/article/details/111677048</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、传入配置类，创建ioc容器</span><br><span class="line"> * 		<span class="number">2</span>）、注册配置类，调用refresh（）刷新容器；</span><br><span class="line"> * 		<span class="number">3</span>）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建；</span><br><span class="line"> * 			<span class="number">1</span>）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class="line"> * 			<span class="number">2</span>）、给容器中加别的BeanPostProcessor</span><br><span class="line"> * 			<span class="number">3</span>）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">4</span>）、再给容器中注册实现了Ordered接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">5</span>）、注册没实现优先级接口的BeanPostProcessor；</span><br><span class="line"> * 			<span class="number">6</span>）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；</span><br><span class="line"> * 				创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】</span><br><span class="line"> * 				<span class="number">1</span>）、创建Bean的实例</span><br><span class="line"> * 				<span class="number">2</span>）、populateBean；给bean的各种属性赋值</span><br><span class="line"> * 				<span class="number">3</span>）、initializeBean：初始化bean；</span><br><span class="line"> * 						<span class="number">1</span>）、invokeAwareMethods()：处理Aware接口的方法回调</span><br><span class="line"> * 						<span class="number">2</span>）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</span><br><span class="line"> * 						<span class="number">3</span>）、invokeInitMethods()；执行自定义的初始化方法</span><br><span class="line"> * 						<span class="number">4</span>）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</span><br><span class="line"> * 				<span class="number">4</span>）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder</span><br><span class="line"> * 			<span class="number">7</span>）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class="line"> * 				beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line"> * =======以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程========</span><br><span class="line"> * </span><br><span class="line"> * 			AnnotationAwareAspectJAutoProxyCreator =&gt; InstantiationAwareBeanPostProcessor</span><br><span class="line"> * 		<span class="number">4</span>）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean</span><br><span class="line"> * 			<span class="number">1</span>）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);</span><br><span class="line"> * 				getBean-&gt;doGetBean()-&gt;getSingleton()-&gt;</span><br><span class="line"> * 			<span class="number">2</span>）、创建bean</span><br><span class="line"> * 				【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】</span><br><span class="line"> * 				<span class="number">1</span>）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；</span><br><span class="line"> * 					只要创建好的Bean都会被缓存起来</span><br><span class="line"> * 				<span class="number">2</span>）、createBean（）;创建bean；</span><br><span class="line"> * 					AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</span><br><span class="line"> * 					【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</span><br><span class="line"> * 					【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】</span><br><span class="line"> * 					<span class="number">1</span>）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation</span><br><span class="line"> * 						希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</span><br><span class="line"> * 						<span class="number">1</span>）、后置处理器先尝试返回对象；</span><br><span class="line"> * 							bean = applyBeanPostProcessorsBeforeInstantiation（）：</span><br><span class="line"> * 								拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;</span><br><span class="line"> * 								就执行postProcessBeforeInstantiation</span><br><span class="line"> * 							<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">								bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">							&#125;</span><br><span class="line"> * </span><br><span class="line"> * 					<span class="number">2</span>）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和<span class="number">3.6</span>流程一样；</span><br><span class="line"> * 					<span class="number">3</span>）、</span><br><span class="line"> * 			</span><br><span class="line"> * 		</span><br><span class="line"> * AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】	的作用：</span><br><span class="line"> * <span class="number">1</span>）、每一个bean创建之前，调用postProcessBeforeInstantiation()；</span><br><span class="line"> * 		关心MathCalculator和LogAspect的创建</span><br><span class="line"> * 		<span class="number">1</span>）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line"> * 		<span class="number">2</span>）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，</span><br><span class="line"> * 			或者是否是切面（<span class="meta">@Aspect</span>）</span><br><span class="line"> * 		<span class="number">3</span>）、是否需要跳过</span><br><span class="line"> * 			<span class="number">1</span>）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line"> * 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class="line"> * 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回<span class="keyword">true</span></span><br><span class="line"> * 			<span class="number">2</span>）、永远返回<span class="keyword">false</span></span><br><span class="line"> * </span><br><span class="line"> * <span class="number">2</span>）、创建对象</span><br><span class="line"> * postProcessAfterInitialization；</span><br><span class="line"> * 		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<span class="comment">//包装如果需要的情况下</span></span><br><span class="line"> * 		<span class="number">1</span>）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class="line"> * 			<span class="number">1</span>、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class="line"> * 			<span class="number">2</span>、获取到能在bean使用的增强器。</span><br><span class="line"> * 			<span class="number">3</span>、给增强器排序</span><br><span class="line"> * 		<span class="number">2</span>）、保存当前bean在advisedBeans中；</span><br><span class="line"> * 		<span class="number">3</span>）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class="line"> * 			<span class="number">1</span>）、获取所有增强器（通知方法）</span><br><span class="line"> * 			<span class="number">2</span>）、保存到proxyFactory</span><br><span class="line"> * 			<span class="number">3</span>）、创建代理对象：Spring自动决定</span><br><span class="line"> * 				JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class="line"> * 				ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class="line"> * 		<span class="number">4</span>）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class="line"> * 		<span class="number">5</span>）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br><span class="line"> * 		</span><br><span class="line"> * 	</span><br><span class="line"> * 	<span class="number">3</span>）、目标方法执行	；</span><br><span class="line"> * 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class="line"> * 		<span class="number">1</span>）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class="line"> * 		<span class="number">2</span>）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class="line"> * 			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"> * 			<span class="number">1</span>）、List&lt;Object&gt; interceptorList保存所有拦截器 <span class="number">5</span></span><br><span class="line"> * 				一个默认的ExposeInvocationInterceptor 和 <span class="number">4</span>个增强器；</span><br><span class="line"> * 			<span class="number">2</span>）、遍历所有的增强器，将其转为Interceptor；</span><br><span class="line"> * 				registry.getInterceptors(advisor);</span><br><span class="line"> * 			<span class="number">3</span>）、将增强器转为List&lt;MethodInterceptor&gt;；</span><br><span class="line"> * 				如果是MethodInterceptor，直接加入到集合中</span><br><span class="line"> * 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class="line"> * 				转换完成返回MethodInterceptor数组；</span><br><span class="line"> * </span><br><span class="line"> * 		<span class="number">3</span>）、如果没有拦截器链，直接执行目标方法;</span><br><span class="line"> * 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class="line"> * 		<span class="number">4</span>）、如果有拦截器链，把需要执行的目标对象，目标方法，</span><br><span class="line"> * 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class="line"> * 			并调用 Object retVal =  mi.proceed();</span><br><span class="line"> * 		<span class="number">5</span>）、拦截器链的触发过程;</span><br><span class="line"> * 			<span class="number">1</span>)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-<span class="number">1</span>大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class="line"> * 			<span class="number">2</span>)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class="line"> * 				拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br><span class="line"> * 		</span><br><span class="line"> * 	总结：</span><br><span class="line"> * 		<span class="number">1</span>）、  <span class="meta">@EnableAspectJAutoProxy</span> 开启AOP功能</span><br><span class="line"> * 		<span class="number">2</span>）、 <span class="meta">@EnableAspectJAutoProxy</span> 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line"> * 		<span class="number">3</span>）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</span><br><span class="line"> * 		<span class="number">4</span>）、容器的创建流程：</span><br><span class="line"> * 			<span class="number">1</span>）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class="line"> * 			<span class="number">2</span>）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class="line"> * 				<span class="number">1</span>）、创建业务逻辑组件和切面组件</span><br><span class="line"> * 				<span class="number">2</span>）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class="line"> * 				<span class="number">3</span>）、组件创建完之后，判断组件是否需要增强</span><br><span class="line"> * 					是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；</span><br><span class="line"> * 		<span class="number">5</span>）、执行目标方法：</span><br><span class="line"> * 			<span class="number">1</span>）、代理对象执行目标方法</span><br><span class="line"> * 			<span class="number">2</span>）、CglibAopProxy.intercept()；</span><br><span class="line"> * 				<span class="number">1</span>）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class="line"> * 				<span class="number">2</span>）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class="line"> * 				<span class="number">3</span>）、效果：</span><br><span class="line"> * 					正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class="line"> * 					出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br><span class="line"> * 		</span><br></pre></td></tr></table></figure>



<h1 id="三，声明式事务"><a href="#三，声明式事务" class="headerlink" title="三，声明式事务"></a>三，声明式事务</h1><p>环境搭建</p>
<p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TxConfig 配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> TxConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 事务配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 18:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zhuang.tx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;*****&quot;</span>);</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource());</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> UserService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Service层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 18:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.insert();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据插入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhuang.tx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> UserDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Dao层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/4/4 18:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by dell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;INSERT INTO `fruit` (`number`,`fruitname`,`price`,`unit`)\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;VALUES(?,?,?,?);&quot;</span>;</span><br><span class="line">        <span class="comment">// 增删改都来调用这个方法</span></span><br><span class="line">        jdbcTemplate.update(sql,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;菠萝&quot;</span>,<span class="string">&quot;5.5&quot;</span>,<span class="string">&quot;kg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(TxConfig.class);</span><br><span class="line">        UserService userService = applicationContext.getBean(UserService.class);</span><br><span class="line">        userService.insert();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://pic.imgdb.cn/item/60eaa9fb5132923bf82e539a.png"></p>
<p><img src="https://pic.imgdb.cn/item/60eaa9fb5132923bf82e53b6.png"></p>
<p>实现事务步骤</p>
<ul>
<li>添加注解**@EnableTransactionManagement** 在配置类上</li>
<li>添加Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事务管理器在容器中</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">platformTransactionManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UserService方法上加 <strong>@Transactional</strong></li>
</ul>
<p>随便搞个异常</p>
<p><img src="https://pic.imgdb.cn/item/60eaaaff5132923bf8342ae1.png"></p>
<p><img src="https://pic.imgdb.cn/item/60eaaaff5132923bf8342b47.png"></p>
<p><strong>实现事务！</strong></p>
<p>原理解析</p>
<p><strong>@EnableTransactionManagement</strong></p>
<p>利用<strong>TransactionManagementConfigurationSelector</strong>给容器中会导入组件导入两个组件</p>
<ul>
<li><p>AutoProxyRegistrar</p>
</li>
<li><p>ProxyTransactionManagementConfiguration</p>
</li>
</ul>
<p><strong>AutoProxyRegistrar：</strong></p>
<p>给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件；</p>
<p>InfrastructureAdvisorAutoProxyCreator：？</p>
<p>利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9oc28"><img src="https://z3.ax1x.com/2021/07/11/W9oc28.png" alt="W9oc28.png"></a></p>
<p><strong>ProxyTransactionManagementConfiguration 做了什么？</strong></p>
<p><strong>给容器中注册事务增强器；</strong></p>
<ul>
<li><p>(1)、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解</p>
</li>
<li><p>(2)、事务拦截器：</p>
</li>
</ul>
<p><strong>TransactionInterceptor；保存了事务属性信息，事务管理器,是一个 MethodInterceptor；在目标方法执行的时候；执行拦截器链；事务拦截器：</strong></p>
<ul>
<li><p>(1)、先获取事务相关的属性</p>
</li>
<li><p>(2)、再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/W9oRKg"><img src="https://z3.ax1x.com/2021/07/11/W9oRKg.png" alt="W9oRKg.png"></a></p>
<p><strong>最终会从容器中按照类型获取一个PlatformTransactionManager；</strong></p>
<ul>
<li>(3)、执行目标方法</li>
</ul>
<p><strong>如果异常，获取到事务管理器，利用事务管理回滚操作；</strong></p>
<p><strong>如果正常，利用事务管理器，提交事务</strong></p>
<h1 id="四，Servlet-3-0"><a href="#四，Servlet-3-0" class="headerlink" title="四，Servlet 3.0"></a>四，Servlet 3.0</h1><p>直接看别人的吧 ，版本不同，问题太多，比较麻烦，有空还是看看源码</p>
<p><strong>参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/yerenyuan_pku/category_10613855.html">https://blog.csdn.net/yerenyuan_pku/category_10613855.html</a></strong></p>
<h1 id="五，拓展"><a href="#五，拓展" class="headerlink" title="五，拓展"></a>五，拓展</h1><p>后续补上！</p>
<p><strong>参考文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/yerenyuan_pku/category_10613855.html">https://blog.csdn.net/yerenyuan_pku/category_10613855.html</a></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">康小庄</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/10/Spring%E6%B3%A8%E8%A7%A3%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2021/02/10/Spring%E6%B3%A8%E8%A7%A3%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">康小庄的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/60eaabe75132923bf8395d69.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/15/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://gitee.com/zhuang-kang/note-picture/raw/master/%E5%9B%BE%E7%89%87/image-20210309155417639.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringMVC学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/05/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://pic.imgdb.cn/item/60c8b5c3844ef46bb2e69576.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/07/SpringBoot学习笔记/" title="SpringBoot学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/60e429695132923bf87fba9c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-07</div><div class="title">SpringBoot学习笔记</div></div></a></div><div><a href="/2021/04/29/Vue学习笔记/" title="Vue学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/60cda866844ef46bb228322f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-29</div><div class="title">Vue学习笔记</div></div></a></div><div><a href="/2021/04/25/Redis学习笔记/" title="Redis学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/60c8ba4c844ef46bb235871e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-25</div><div class="title">Redis学习笔记</div></div></a></div><div><a href="/2021/04/20/Linux学习笔记/" title="Linux学习笔记"><img class="cover" src="https://pic.imgdb.cn/item/60cdad74844ef46bb256128d.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="title">Linux学习笔记</div></div></a></div><div><a href="/2021/04/18/RabbitMQ笔记/" title="RabbitMQ笔记"><img class="cover" src="https://z3.ax1x.com/2021/06/01/2KKeTs.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-18</div><div class="title">RabbitMQ笔记</div></div></a></div><div><a href="/2021/04/13/正则表达式学习笔记/" title="Java正则表达式"><img class="cover" src="https://pic.imgdb.cn/item/60cda6bc844ef46bb219b40a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-13</div><div class="title">Java正则表达式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%B3%A8%E8%A7%A3%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Spring注解版学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CIOC"><span class="toc-number">2.</span> <span class="toc-text">一，IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Configuration%E5%92%8C-Bean%E7%BB%99%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1. 使用@Configuration和@Bean给容器中注册组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 配置文件方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 注解方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-ComponentScan%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E7%BB%84%E4%BB%B6%E5%B9%B6%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E8%A7%84%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">2. 使用@ComponentScan自动扫描组件并指定扫描规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-ComponentScan-%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 @ComponentScan 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Scope%E6%B3%A8%E8%A7%A3%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3. 使用@Scope注解设置组件的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Scope%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1@Scope注解概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8D%95%E5%AE%9E%E4%BE%8Bbean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 单实例bean作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%A4%9A%E5%AE%9E%E4%BE%8Bbean%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 多实例bean作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8D%95%E5%AE%9E%E4%BE%8Bbean%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 单实例bean注意的事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A4%9A%E5%AE%9E%E4%BE%8Bbean%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 多实例bean注意的事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.4.</span> <span class="toc-text">4. 懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8C%89%E7%85%A7%E6%9D%A1%E4%BB%B6%E5%90%91Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8CBean"><span class="toc-number">2.5.</span> <span class="toc-text">5. 按照条件向Spring容器中注册Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Conditional%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 @Conditional注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8-Import%E6%B3%A8%E8%A7%A3%E7%BB%99%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AF%BC%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">2.6.</span> <span class="toc-text">6. 使用@Import注解给容器中导入一个组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%B3%A8%E5%86%8Cbean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1 注册bean的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Import%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2 @Import注解概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Import%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3 @Import注解的使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9C%A8-Import%E6%B3%A8%E8%A7%A3%E4%B8%AD%E4%BD%BF%E7%94%A8ImportSelector%E6%8E%A5%E5%8F%A3%E5%AF%BC%E5%85%A5bean"><span class="toc-number">2.7.</span> <span class="toc-text">7. 在@Import注解中使用ImportSelector接口导入bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%A8-Import%E6%B3%A8%E8%A7%A3%E4%B8%AD%E4%BD%BF%E7%94%A8ImportBeanDefinitionRegistrar%E5%90%91%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8Cbean"><span class="toc-number">2.8.</span> <span class="toc-text">8. 在@Import注解中使用ImportBeanDefinitionRegistrar向容器中注册bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%BD%BF%E7%94%A8FactoryBean%E5%90%91Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%B3%A8%E5%86%8Cbean"><span class="toc-number">2.9.</span> <span class="toc-text">9. 使用FactoryBean向Spring容器中注册bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E8%A7%A3%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">10. 使用@Bean注解指定初始化和销毁的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.10.1.</span> <span class="toc-text">10.1bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.10.2.</span> <span class="toc-text">10.2 如何定义初始化和销毁方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.10.3.</span> <span class="toc-text">10.3 指定初始化和销毁方法的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BD%BF%E7%94%A8InitializingBean%E5%92%8CDisposableBean%E6%9D%A5%E7%AE%A1%E7%90%86bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.11.</span> <span class="toc-text">11. 使用InitializingBean和DisposableBean来管理bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-InitializingBean%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.11.1.</span> <span class="toc-text">11.1 InitializingBean接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-DisposableBean%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.11.2.</span> <span class="toc-text">11.2 DisposableBean接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">2.11.3.</span> <span class="toc-text">11.3 单实例案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E6%A1%88%E4%BE%8B"><span class="toc-number">2.11.4.</span> <span class="toc-text">11.4 多实例案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-PostConstruct%E6%B3%A8%E8%A7%A3%E5%92%8C-PreDestroy%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.12.</span> <span class="toc-text">12. @PostConstruct注解和@PreDestroy注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-PostConstruct%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.12.1.</span> <span class="toc-text">12.1 @PostConstruct注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-PreDestroy%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.12.2.</span> <span class="toc-text">12.2 @PreDestroy注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E6%A1%88%E4%BE%8B"><span class="toc-number">2.12.3.</span> <span class="toc-text">12.3 案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-BeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.13.</span> <span class="toc-text">13. BeanPostProcessor后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-BeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.1.</span> <span class="toc-text">13.1 BeanPostProcessor后置处理器实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-BeanPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">2.13.2.</span> <span class="toc-text">13.2 BeanPostProcessor后置处理器作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-BeanPostProcessor%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.14.</span> <span class="toc-text">14. BeanPostProcessor的执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1"><span class="toc-number">2.14.1.</span> <span class="toc-text">14.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2"><span class="toc-number">2.14.2.</span> <span class="toc-text">14.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3"><span class="toc-number">2.14.3.</span> <span class="toc-text">14.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4"><span class="toc-number">2.14.4.</span> <span class="toc-text">14.4</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-BeanPostProcessor%E5%9C%A8Spring%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.15.</span> <span class="toc-text">15. BeanPostProcessor在Spring底层是如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-ApplicationContextAwareProcessor"><span class="toc-number">2.15.1.</span> <span class="toc-text">15.1 ApplicationContextAwareProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-BeanValidationPostProcessor%E7%B1%BB"><span class="toc-number">2.15.2.</span> <span class="toc-text">15.2 BeanValidationPostProcessor类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-InitDestroyAnnotationBeanPostProcessor%E7%B1%BB"><span class="toc-number">2.15.3.</span> <span class="toc-text">15.3 InitDestroyAnnotationBeanPostProcessor类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-AutowiredAnnotationBeanPostProcessor%E7%B1%BB"><span class="toc-number">2.15.4.</span> <span class="toc-text">15.4 AutowiredAnnotationBeanPostProcessor类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%BD%BF%E7%94%A8-Value%E6%B3%A8%E8%A7%A3%E4%B8%BAbean%E7%9A%84%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC"><span class="toc-number">2.16.</span> <span class="toc-text">16. 使用@Value注解为bean的属性赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BD%BF%E7%94%A8-PropertySource%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.17.</span> <span class="toc-text">17. 使用@PropertySource加载配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-%E4%BD%BF%E7%94%A8Environment%E8%8E%B7%E5%8F%96%E5%80%BC"><span class="toc-number">2.17.1.</span> <span class="toc-text">17.1 使用Environment获取值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BD%BF%E7%94%A8-Autowired%E3%80%81-Qualifier%E3%80%81-Primary%E8%BF%99%E4%B8%89%E5%A4%A7%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%BB%84%E4%BB%B6"><span class="toc-number">2.18.</span> <span class="toc-text">18. 使用@Autowired、@Qualifier、@Primary这三大注解自动装配组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-Autowired%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.18.1.</span> <span class="toc-text">18.1 @Autowired注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-Qualifier%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.18.2.</span> <span class="toc-text">18.2 @Qualifier注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-Primary%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.18.3.</span> <span class="toc-text">18.3 @Primary注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BD%BF%E7%94%A8-Resource%E6%B3%A8%E8%A7%A3%E5%92%8C-Inject%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.19.</span> <span class="toc-text">19. 使用@Resource注解和@Inject注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-Resource%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.19.1.</span> <span class="toc-text">19.1 @Resource注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-Inject%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.19.2.</span> <span class="toc-text">19.2 @Inject注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%BD%BF%E7%94%A8-Profile%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%BC%80%E5%8F%91%E3%80%81%E6%B5%8B%E8%AF%95%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E6%8D%A2"><span class="toc-number">2.20.</span> <span class="toc-text">20. 使用@Profile注解实现开发、测试和生产环境的配置和切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1-Profile%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.20.1.</span> <span class="toc-text">20.1 @Profile注解概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CAOP"><span class="toc-number">3.</span> <span class="toc-text">二，AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAAOP%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.</span> <span class="toc-text">1. 搭建一个AOP测试环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EnableAspectJAutoProxy%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">2. @EnableAspectJAutoProxy注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BAAnnotationAwareAspectJAutoProxyCreator%E7%BB%84%E4%BB%B6%E9%87%8C%E9%9D%A2%E5%92%8C%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BB%A5%E5%8F%8AAware%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E6%89%93%E4%B8%8A%E6%96%AD%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">3.为AnnotationAwareAspectJAutoProxyCreator组件里面和后置处理器以及Aware接口有关的方法打上断点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8CAnnotationAwareAspectJAutoProxyCreator%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">4. 分析创建和注册AnnotationAwareAspectJAutoProxyCreator的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-AnnotationAwareAspectJAutoProxyCreator%E4%BD%9C%E4%B8%BA%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5. AnnotationAwareAspectJAutoProxyCreator作为后置处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E6%8B%A6%E6%88%AA%E9%80%BB%E8%BE%91"><span class="toc-number">3.6.</span> <span class="toc-text">6. 目标方法的拦截逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">7. 拦截器链的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-AOP%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.</span> <span class="toc-text">8. AOP总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">三，声明式事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8CServlet-3-0"><span class="toc-number">5.</span> <span class="toc-text">四，Servlet 3.0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E6%8B%93%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">五，拓展</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://pic.imgdb.cn/item/60eaabe75132923bf8395d69.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 康小庄</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div align=center><a href="http://beian.miit.gov.cn/"; target=_blank>苏ICP备2021027330</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.16/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?Kang-xiao-zhuang";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="Kang-xiao-zhuang";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style>undefined</style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>